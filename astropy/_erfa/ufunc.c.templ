/* -*- mode: c -*- */

/* Licensed under a 3-clause BSD style license - see LICENSE.rst */

/*
 * "ufunc.c" is auto-generated by erfa_generator.py from the template
 * "ufunc.c.templ". Do *not* edit "ufunc.c" directly, instead edit
 * "ufunc.c.templ" and run ufunc_generator.py from the source directory
 * to update it.
 */

#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include "Python.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#include "erfa.h"
#include "erfaextra.h"
#include "erfa_additions.h"

#define MODULE_DOCSTRING \
    "Ufunc wrappers of the ERFA routines.\n\n" \
    "These ufuncs vectorize the ERFA functions assuming structured dtypes\n" \
    "for vector and matrix arguments. Status codes are vectors as well.\n" \
    "Python wrappers are also provided, which convert between\n" \
    "trailing dimensions and structured dtypes where necessary,\n" \
    "and combine status codes."
#define GET_LEAP_SECONDS_DOCSTRING \
    "get_leap_seconds()\n\n" \
    "Access the leap second table used in ERFA.\n\n" \
    "Returns\n" \
    "-------\n" \
    "leap_seconds : `~numpy.ndarray`\n" \
    "    With structured dtype `~astropy._erfa.dt_eraLEAPSECOND`,\n" \
    "    containing items 'year', 'month', and 'tai_utc'."
#define SET_LEAP_SECONDS_DOCSTRING \
    "set_leap_seconds([table])\n\n" \
    "Set the leap second table used in ERFA.\n\n" \
    "Parameters\n" \
    "----------\n" \
    "leap_seconds : array_like, optional\n" \
    "    With structured dtype `~astropy._erfa.dt_eraLEAPSECOND`,\n" \
    "    containing items 'year', 'month', and 'tai_utc'.\n" \
    "    If not given, reset to the ERFA built-in table.\n\n" \
    "Notes\n" \
    "-----\n" \
    "No sanity checks are done on the input; it is simply coerced\n" \
    "to the correct dtype."


static inline void copy_to_double3(char *ptr, npy_intp s, double d[3]) {
    char *p = ptr;
    int j;
    for (j = 0; j < 3; j++, p += s) {
        d[j] = *(double *)p;
    }
}

static inline void copy_from_double3(char *ptr, npy_intp s, double d[3]) {
    char *p = ptr;
    int j;
    for (j = 0; j < 3; j++, p += s) {
        *(double *)p = d[j];
    }
}

static inline void copy_to_double33(char *ptr, npy_intp s0, npy_intp s1,
                                    double d[3][3]) {
    char *p0 = ptr;
    int j0, j1;
    for (j0 = 0; j0 < 3; j0++, p0 += s0) {
        char *p1 = p0;
        for (j1 = 0; j1 < 3; j1++, p1 += s1) {
            d[j0][j1] = *(double *)p1;
        }
    }
}

static inline void copy_from_double33(char *ptr, npy_intp s0, npy_intp s1,
                                      double d[3][3]) {
    char *p = ptr;
    char *p0 = ptr;
    int j0, j1;
    for (j0 = 0; j0 < 3; j0++, p0 += s0) {
        char *p1 = p0;
        for (j1 = 0; j1 < 3; j1++, p1 += s1) {
            *(double *)p = d[j0][j1];
        }
    }
}

/* eraLDBODY is never returned, so we do not need a copy_from */
static inline void copy_to_eraLDBODY(char *ptr, npy_intp s, npy_intp n,
                                  eraLDBODY b[]) {
    char *p = ptr;
    npy_intp j;
    for (j = 0; j < n; j++, p += s) {
        b[j] = *(eraLDBODY *)p;
    }
}

/*
 * INNER LOOPS - iteratively call the erfa function for a chunk of data.
 *
 * For each argument:
 * char *<name> is the pointer to the data in memory;
 * npy_intp s_<name> is the number of bytes between successive elements;
 * <ctype> *_<name> is a correctly cast pointer to the current element;
 * (<ctype> _<name>, i.e., not a pointer, for status codes and return values)
 *
 * Notes:
 * 1. Some erfa function change elements in-place; in the ufunc, these "inout"
 *    arguments are treated as separate: data is copied from the input to the
 *    output, and the output is changed in-place by the erfa function.
 *    To reproduce the in-place behaviour, the input to the ufunc can be passed
 *    in as output as well -- as is done in the python wrapper (the copy will
 *    be omitted for this case).
 * 2. Any erfa function involving light deflection requires an struct
 *    eraLDBODY argument with a dimension that is user-defined. Those function
 *    are implemented as generalized ufuncs, with a signature in which the
 *    relevant variable is marked (i.e., '(),...,(n), (), ... -> (),...').
 *    In the inner loops, an appropriate copy is done if in the numpy array
 *    the n elements are not contiguous.
 * 3. Similar copies are done for erfa functions that require vectors or
 *    matrices, if the corresponding axes in the input or output operands are
 *    not contiguous.
 */

{%- macro inner_loop_steps_and_copy(arg, arg_name) %}
  {%- for i in range(arg.ndim or 1) %}
    npy_intp is_{{ arg_name }}{{ i }} = *steps++;
  {%- endfor %}
  {#- /* copy should be made if buffer not contiguous;
         note: one can only have 1 or 2 dimensions */ #}
  {%- if arg.ndim == 2 %}
    int copy_{{ arg_name
        }} = (is_{{ arg_name }}1 != sizeof({{ arg.ctype }}) &&
              is_{{ arg_name }}0 != {{ arg.shape[1] }} * sizeof({{ arg.ctype }}));
  {%- else %}
    int copy_{{ arg_name }} = (is_{{ arg_name }}0 != sizeof({{ arg.ctype }}));
  {%- endif %}
{%- endmacro %}

{%- for func in funcs %}

static void ufunc_loop_{{ func.pyname }}(
    char **args, npy_intp *dimensions, npy_intp* steps, void* data)
{
  {#- /* index and length of loop */ #}
    npy_intp i_o;
    npy_intp n_o = *dimensions++;
  {#- /*
       * Pointers to each argument, required step size
       */ #}
  {#- /* normal input arguments */ #}
  {%- for arg in func.args_by_inout('in') %}
    char *{{ arg.name }} = *args++;
    npy_intp s_{{ arg.name }} = *steps++;
  {%- endfor -%}
  {#- /* for in part of in-place arguments, we need a different name */ #}
  {%- for arg in func.args_by_inout('inout') %}
    char *{{ arg.name }}_in = *args++;
    npy_intp s_{{ arg.name }}_in = *steps++;
  {%- endfor -%}
  {#- /* out part of input, and output arguments, including status */ #}
  {%- for arg in func.args_by_inout('inout|out|stat|ret') %}
    char *{{ arg.name }} = *args++;
    npy_intp s_{{ arg.name }} = *steps++;
  {%- endfor -%}
  {#- /*
       * Cast pointers and possible contiguous buffers (for gufuncs)
       */ #}
  {%- for arg in func.args_by_inout('in|inout|out') %}
   {%- if arg.signature_shape == '()' or arg.ctype == 'eraLDBODY'  %}
    {{ arg.ctype }} (*_{{ arg.name }}){{ arg.cshape }};
   {%- else %}
    double b_{{ arg.name }}{{ arg.cshape }};
    {{ arg.ctype }} (*_{{ arg.name }}){{ arg.cshape }} = &b_{{ arg.name }};
   {%- endif %}
  {%- endfor %}
  {#- /* variables to hold status and return values */ #}
  {%- for arg in func.args_by_inout('stat|ret') %}
    {{ arg.ctype }} _{{ arg.name }};
  {%- endfor %}
  {#- /*
       * For GENERALIZED UFUNCS - inner loop steps, needs for copying.
       */ #}
  {%- if func.signature %}
   {#- /* loop step sizes and whether copies are needed */ #}
   {%- for arg in func.args_by_inout('in') %}
    {#- /* only LDBODY has non-fixed dimension; it is always first */ #}
    {%- if arg.ctype == 'eraLDBODY' %}
    npy_intp nb = dimensions[0];
    {%- endif %}
    {%- if arg.signature_shape != '()' -%}
    {{ inner_loop_steps_and_copy(arg, arg.name) }}
    {%- endif %}
   {%- endfor %}
   {%- for arg in func.args_by_inout('inout') %}
    {%- if arg.signature_shape != '()' -%}
    {{ inner_loop_steps_and_copy(arg, arg.name + '_in') }}
    {%- endif %}
   {%- endfor %}
   {%- for arg in func.args_by_inout('inout|out') %}
    {%- if arg.signature_shape != '()' -%}
    {{ inner_loop_steps_and_copy(arg, arg.name) }}
    {%- endif %}
   {%- endfor %}
   {#- /* if needed, allocate memory for contiguous eraLDBODY copies */ #}
   {%- if func.user_dtype == 'dt_eraLDBODY' %}
    if (copy_b) {
        _b = PyArray_malloc(nb * sizeof(eraLDBODY));
        if (_b == NULL) {
            PyErr_NoMemory();
            return;
        }
    }
    else { {#- /* just to keep compiler happy */ #}
        _b = NULL;
    }
   {%- endif %}
  {%- endif %} {#- /* end of GUFUNC inner loop definitions */ #}
  {#- /*
       * Actual inner loop, increasing all pointers by their steps
       */ #}
    for (i_o = 0; i_o < n_o;
         i_o++ {%- for arg in func.args_by_inout('in|inout|out|stat|ret') -%}
             , {{ arg.name }} += s_{{ arg.name }}
             {%- endfor -%}
             {%- for arg in func.args_by_inout('inout') -%}
             , {{ arg.name }}_in += s_{{ arg.name }}_in
             {%- endfor -%}) {
      {%- if func.signature %}
       {#- /*
            * GENERALIZED UFUNC, prepare for call.
            */ #}
       {#- /* copy input arguments to buffer if needed */ #}
       {%- for arg in func.args_by_inout('in') %}
        {%- if arg.signature_shape != '()' %}
        if (copy_{{ arg.name }}) {
            copy_to_{{ arg.ctype }}{{ arg.shape|join('') }}({{ arg.name }}
                {%- for i in range(arg.ndim or 1) -%}
                , is_{{ arg.name }}{{ i }}
                {%- endfor %}, {{ arg.name_for_call}});
        }
        else {
            _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        }
        {%- else %}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        {%- endif %}
       {%- endfor %} {#- end of loop over 'in' #}
       {#- /* for inout arguments, set up output first,
              and then copy to it if needed */ #}
       {%- for arg in func.args_by_inout('inout') %}
        {%- if arg.signature_shape != '()' %}
        if (!copy_{{ arg.name }}) {
            _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        }
        if (copy_{{ arg.name }}_in || {{ arg.name }} != {{ arg.name }}_in) {
            copy_to_{{ arg.ctype }}{{ arg.shape|join('') }}({{ arg.name }}_in
                {%- for i in range(arg.ndim or 1) -%}
                , is_{{ arg.name }}_in{{ i }}
                {%- endfor %}, {{ arg.name_for_call}});
        }
        {%- else %}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        if ({{ arg.name }}_in != {{ arg.name }}) {
            memcpy({{ arg.name }}, {{ arg.name }}_in, {{ arg.size }}*sizeof({{ arg.ctype }}));
        }
        {%- endif %}
       {%- endfor %} {#- end of loop over 'inout' #}
       {#- /* set up gufunc outputs */ #}
       {%- for arg in func.args_by_inout('out') %}
        {%- if arg.signature_shape != '()' %}
        if (!copy_{{ arg.name }}) {
            _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        }
        {%- else %}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        {%- endif %}
       {%- endfor %} {#- end of loop over 'out' #}
      {%- else %}
       {#- /*
            * NORMAL UFUNC, prepare for call
            */ #}
       {#- /* set up pointers to input/output arguments */ #}
       {%- for arg in func.args_by_inout('in|inout|out') %}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
       {%- endfor %}
       {#- /* copy from in to out for arugments changed in-place */ #}
       {%- for arg in func.args_by_inout('inout') %}
        if ({{ arg.name }}_in != {{ arg.name }}) {
            memcpy({{ arg.name }}, {{ arg.name }}_in, {{ arg.size }}*sizeof({{ arg.ctype }}));
        }
       {%- endfor %}
      {%- endif %} {#- end of gufunc/ufunc preparation #}
      {#- /*
           * call the actual erfa function
           */ #}
        {{ func.args_by_inout('ret|stat') |
                    map(attribute='name') |
                    surround('_', ' = ') |
                    join
        }}{{ func.name
        }}({{ func.args_by_inout('in|inout|out') |
                    map(attribute='name_for_call') |
                    join(', ') }});
      {#- /* store any return values */ #}
      {%- for arg in func.args_by_inout('ret|stat') %}
        *(({{ arg.ctype }} *){{ arg.name }}) = _{{ arg.name }};
      {%- endfor %}
      {%- if func.signature %}
       {#- /* for generalized ufunc, copy output from buffer if needed */ #}
       {%- for arg in func.args_by_inout('inout|out') %}
        {%- if arg.signature_shape != '()' %}
        if (copy_{{ arg.name }}) {
            copy_from_{{ arg.ctype }}{{ arg.shape|join('') }}({{ arg.name }}
                {%- for i in range(arg.ndim or 1) -%}
                , is_{{ arg.name }}{{ i }}
                {%- endfor %}, {{ arg.name_for_call}});
        }
        {%- endif %}
       {%- endfor %}
      {%- endif %}
    }
    {%- if func.user_dtype == 'dt_eraLBODY' %}
    if (copy_b) {
        PyArray_free(_b);
    }
    {%- endif %}
}

{%- endfor %}

/*
 * UFUNC LOOP MATCHING HELPERS
 * All but ufunc_loop_matches are copies of code needed but not exported.
 */

/*
 * Adjusted version of ufunc_loop_matches from
 * numpy/core/src/umath/ufunc_type_resolution.c.
 * Here, we special-case the structured dtype check, only allowing
 * casting of the same dtype or string.  We also do not distinguish
 * between input and output arguments for casting.
 */
static int
ufunc_loop_matches(PyUFuncObject *self,
                   PyArrayObject **op,
                   NPY_CASTING casting,
                   int *types, PyArray_Descr **dtypes)
{
    npy_intp i, nin = self->nin, nop = nin + self->nout;
    /*
     * Check if all the inputs can be cast to the types used by this function.
     */
    for (i = 0; i < nin; ++i) {
        PyArray_Descr *op_descr = PyArray_DESCR(op[i]);
        /*
         * Check for NPY_VOID with an associated struct dtype.
         */
        if (types[i] == NPY_VOID && dtypes != NULL) {
            int op_descr_type_num = op_descr->type_num;
            int dtype_elsize = dtypes[i]->elsize;
            /*
             * MHvK: we do our own check on casting, since by default
             * all items can cast to structured dtypes (see gh-11114),
             * which is not OK. So, we only allow VOID->same VOID,
             * and STRING -> VOID-of-STRING (which works well; we
             * recognize VOID-of-STRING by the dtype element size;
             * it would be rather costly to go look at dtype->fields).
             */
            if (op_descr_type_num == NPY_VOID) {
                /* allow only the same structured to structured */
                if (!PyArray_EquivTypes(op_descr, dtypes[i])) {
                    return 0;
                }
            }
            else if (dtypes[i]->elsize == 1 || dtypes[i]->elsize == 12) {
                /* string structured array; string argument is OK */
                if (!((op_descr_type_num == NPY_STRING &&
                       op_descr->elsize <= dtype_elsize) ||
                      (op_descr_type_num == NPY_UNICODE &&
                       op_descr->elsize >> 2 <= dtype_elsize))) {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        else { /* non-void function argument */
            PyArray_Descr *tmp = PyArray_DescrFromType(types[i]);
            if (tmp == NULL) {
                return -1;
            }
            if (!PyArray_CanCastTypeTo(op_descr, tmp, casting)) {
                Py_DECREF(tmp);
                return 0;
            }
            Py_DECREF(tmp);
        }
    }
    /*
     * All inputs were ok; now check casting back to the outputs.
     * MHvK: Since no casting from structured to non-structured is
     * possible, no changes needed here.
     */
    for (i = nin; i < nop; ++i) {
        if (op[i] != NULL) {
            PyArray_Descr *tmp = PyArray_DescrFromType(types[i]);
            if (tmp == NULL) {
                return -1;
            }
            if (!PyArray_CanCastTypeTo(tmp, PyArray_DESCR(op[i]),
                                       casting)) {
                Py_DECREF(tmp);
                return 0;
            }
            Py_DECREF(tmp);
        }
    }
    return 1;
}
/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since this translation function is not exported.
 */
static const char *
npy_casting_to_string(NPY_CASTING casting)
{
    switch (casting) {
        case NPY_NO_CASTING:
            return "'no'";
        case NPY_EQUIV_CASTING:
            return "'equiv'";
        case NPY_SAFE_CASTING:
            return "'safe'";
        case NPY_SAME_KIND_CASTING:
            return "'same_kind'";
        case NPY_UNSAFE_CASTING:
            return "'unsafe'";
        default:
            return "<unknown>";
    }
}

/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since not exported.
 */
static PyArray_Descr *
ensure_dtype_nbo(PyArray_Descr *type)
{
    if (PyArray_ISNBO(type->byteorder)) {
        Py_INCREF(type);
        return type;
    }
    else {
        return PyArray_DescrNewByteorder(type, NPY_NATIVE);
    }
}

/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since not exported.
 */
static int
set_ufunc_loop_data_types(PyUFuncObject *self, PyArrayObject **op,
                    PyArray_Descr **out_dtypes,
                    int *type_nums, PyArray_Descr **dtypes)
{
    int i, nin = self->nin, nop = nin + self->nout;

    /*
     * Fill the dtypes array.
     * For outputs,
     * also search the inputs for a matching type_num to copy
     * instead of creating a new one, similarly to preserve metadata.
     **/
    for (i = 0; i < nop; ++i) {
        if (dtypes != NULL) {
            out_dtypes[i] = dtypes[i];
            Py_XINCREF(out_dtypes[i]);
        /*
         * Copy the dtype from 'op' if the type_num matches,
         * to preserve metadata.
         */
        }
        else if (op[i] != NULL &&
                 PyArray_DESCR(op[i])->type_num == type_nums[i]) {
            out_dtypes[i] = ensure_dtype_nbo(PyArray_DESCR(op[i]));
        }
        /*
         * For outputs, copy the dtype from op[0] if the type_num
         * matches, similarly to preserve metdata.
         */
        else if (i >= nin && op[0] != NULL &&
                            PyArray_DESCR(op[0])->type_num == type_nums[i]) {
            out_dtypes[i] = ensure_dtype_nbo(PyArray_DESCR(op[0]));
        }
        /* Otherwise create a plain descr from the type number */
        else {
            out_dtypes[i] = PyArray_DescrFromType(type_nums[i]);
        }

        if (out_dtypes[i] == NULL) {
            goto fail;
        }
    }

    return 0;

fail:
    while (--i >= 0) {
        Py_DECREF(out_dtypes[i]);
        out_dtypes[i] = NULL;
    }
    return -1;
}

/*
 * UFUNC TYPE RESOLVER
 *
 * We provide our own type resolver, since the default one,
 * PyUFunc_DefaultTypeResolver from
 * numpy/core/src/umath/ufunc_type_resolution.c, has problems:
 * 1. It only looks for userloops if any of the operands have a user
 *    type, which does not work if the inputs are normal and no explicit
 *    output is given (see https://github.com/numpy/numpy/issues/11109).
 * 2. It only allows "safe" casting of inputs, which annoyingly prevents
 *    passing in a python int for int32 input.
 * The resolver below solves both, and speeds up the process by
 * explicitly assuming that a ufunc has only one function built in,
 * either a regular one or a userloop (for structured dtype).
 *
 * Combines code from linear_search_type_resolver and
 * linear_search_userloop_type_resolver from
 * numpy/core/src/umath/ufunc_type_resolution.c
 */
static int ErfaUFuncTypeResolver(PyUFuncObject *ufunc,
                                 NPY_CASTING casting,
                                 PyArrayObject **operands,
                                 PyObject *type_tup,
                                 PyArray_Descr **out_dtypes)
{
    int *types;
    PyArray_Descr **dtypes;

    if (ufunc->userloops) {
        Py_ssize_t unused_pos = 0;
        PyObject *userloop;
        PyUFunc_Loop1d *funcdata;

        if (ufunc->ntypes > 0 || PyDict_Size(ufunc->userloops) != 1) {
            goto fail;
        }
        /* No iteration needed; only one entry in dict */
        PyDict_Next(ufunc->userloops, &unused_pos, NULL, &userloop);
        funcdata = (PyUFunc_Loop1d *)PyCapsule_GetPointer(userloop, NULL);
        /* There should be only one function */
        if (funcdata->next != NULL) {
            goto fail;
        }
        types = funcdata->arg_types;
        dtypes = funcdata->arg_dtypes;
    }
    else {
        npy_intp j;
        int types_array[NPY_MAXARGS];

        if (ufunc->ntypes != 1) {
            goto fail;
        }
        /* Copy the types into an int array for matching */
        for (j = 0; j < ufunc->nargs; ++j) {
            types_array[j] = ufunc->types[j];
        }
        types = types_array;
        dtypes = NULL;
    }
    switch (ufunc_loop_matches(ufunc, operands, casting, types, dtypes)) {
    case 1:  /* Matching types */
        return set_ufunc_loop_data_types(ufunc, operands, out_dtypes,
                                         types, dtypes);
    case -1:   /* Error */
        return -1;
    }
    /* No match */
    PyErr_Format(PyExc_TypeError,
                 "ufunc '%s' not supported for the input types, and the "
                 "inputs could not be safely coerced to any supported "
                 "types according to the casting rule '%s'",
                 ufunc->name, npy_casting_to_string(casting));
    return -1;

fail:
    /* More than one loop or function */
    PyErr_Format(PyExc_RuntimeError,
                 "Unexpected internal error: ufunc '%s' wraps an ERFA "
                 "function and should have only a single loop with a "
                 "single function, yet has more.",
                 ufunc->name);
    return -1;
}

/*
 * LEAP SECOND ACCESS
 *
 * Getting/Setting ERFAs built-in TAI-UTC table.
 *
 * TODO: the whole procedure is not sub-interpreter safe.
 * In this module, one might get dt_eraLEAPSECOND out of the module dict,
 * and store the leap_second array in a per-module struct (see PEP 3121).
 * But one then would also have to adapt erfa/dat.c to not use a
 * static leap second table.  Possibly best might be to copy dat.c here
 * and put the table into the per-module struct as well.
 */
static PyArray_Descr *dt_eraLEAPSECOND = NULL;  /* Set in PyInit_ufunc */

static PyObject *
get_leap_seconds(PyObject *NPY_UNUSED(module), PyObject *NPY_UNUSED(args)) {
    eraLEAPSECOND *leapseconds;
    npy_intp count;
    PyArrayObject *array;
    /* Get the leap seconds from ERFA */
    count = (npy_intp)eraGetLeapSeconds(&leapseconds);
    if (count < 0) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Unpexected failure to get ERFA leap seconds.");
        return NULL;
    }
    /* Allocate an array to hold them */
    Py_INCREF(dt_eraLEAPSECOND);
    array = (PyArrayObject *)PyArray_NewFromDescr(
        &PyArray_Type, dt_eraLEAPSECOND, 1, &count, NULL, NULL, 0, NULL);
    if (array == NULL) {
        return NULL;
    }
    /* Copy the leap seconds over into the array */
    memcpy(PyArray_DATA(array), leapseconds, count*sizeof(eraLEAPSECOND));
    return (PyObject *)array;
}

static PyObject *
set_leap_seconds(PyObject *NPY_UNUSED(module), PyObject *args) {
    PyObject *leap_seconds = NULL;
    PyArrayObject *array;
    static PyArrayObject *leap_second_array = NULL;

    if (!PyArg_ParseTuple(args, "|O:set_leap_seconds", &leap_seconds)) {
        return NULL;
    }
    if (leap_seconds != NULL && leap_seconds != Py_None) {
        /*
         * Convert the input to an array with the proper dtype;
         * Ensure a copy is made so one cannot change the data by changing
         * the input array.
         */
        Py_INCREF(dt_eraLEAPSECOND);
        array = (PyArrayObject *)PyArray_FromAny(leap_seconds, dt_eraLEAPSECOND,
                    1, 1, (NPY_ARRAY_CARRAY | NPY_ARRAY_ENSURECOPY), NULL);
        if (array == NULL) {
            return NULL;
        }
        if (PyArray_SIZE(array) == 0) {
            PyErr_SetString(PyExc_ValueError,
                            "Leap second array must have at least one entry.");
        }
        /*
         * Use the array for the new leap seconds.
         */
        eraSetLeapSeconds(PyArray_DATA(array), PyArray_SIZE(array));
    }
    else {
        /*
         * If no input is given, reset leap second table.
         */
        array = NULL;
        eraSetLeapSeconds(NULL, 0);
    }
    /*
     * If we allocated a leap second array before, deallocate it,
     * and set it to remember any allocation from PyArray_FromAny.
     */
    if (leap_second_array != NULL) {
        Py_DECREF(leap_second_array);
    }
    leap_second_array = array;
    Py_RETURN_NONE;
}

/*
 * UFUNC MODULE DEFINITIONS AND INITIALIZATION
 */
static PyMethodDef ErfaUFuncMethods[] = {
    {"get_leap_seconds", (PyCFunction)get_leap_seconds,
         METH_NOARGS, GET_LEAP_SECONDS_DOCSTRING},
    {"set_leap_seconds", (PyCFunction)set_leap_seconds,
         METH_VARARGS, SET_LEAP_SECONDS_DOCSTRING},
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "ufunc",
    MODULE_DOCSTRING,
    -1,
    ErfaUFuncMethods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_ufunc(void)
{
    /* module and its dict */
    PyObject *m, *d;
    /* structured dtypes and their definition */
    PyObject *dtype_def;
    PyArray_Descr *dt_double = NULL, *dt_int = NULL;
    PyArray_Descr *dt_pv = NULL, *dt_pvdpv = NULL;
    PyArray_Descr *dt_ymdf = NULL, *dt_hmsf = NULL, *dt_dmsf = NULL;
    PyArray_Descr *dt_sign = NULL, *dt_type = NULL;
    PyArray_Descr *dt_eraASTROM = NULL, *dt_eraLDBODY = NULL;
    PyArray_Descr *dtypes[NPY_MAXARGS];
    /* ufuncs and their definitions */
    int status;
    PyUFuncObject *ufunc;
    static void *data[1] = {NULL};
    {#- /* for non-structured functions, define there types and functions
           as these do not get copied */ #}
    {%- for func in funcs %}
    {%- if not func.user_dtype %}
    static char types_{{ func.pyname }}[{{ func.args_by_inout('in|inout|out|ret|stat')|count }}] = { {{ func.args_by_inout('in|inout|out|ret|stat')|map(attribute='npy_type')|join(', ') }} };
    static PyUFuncGenericFunction funcs_{{ func.pyname }}[1] = { &ufunc_loop_{{ func.pyname }} };
    {%- endif %}
    {%- endfor %}

    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }
    d = PyModule_GetDict(m); /* borrowed ref. */
    if (d == NULL) {
        goto fail;
    }

    import_array();
    import_umath();
    /*
     * Define the basic and structured types used in erfa so that
     * we can use them for definitions of userloops below.
     */
    dt_double = PyArray_DescrFromType(NPY_DOUBLE);
    dt_int = PyArray_DescrFromType(NPY_INT);
    /* double[2][3] = pv */
    dtype_def = Py_BuildValue("[(s, s), (s, s)]",
                              "p", "(3,)f8", "v", "(3,)f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_pv);
    Py_DECREF(dtype_def);
    /* double[2] = pvdpv */
    dtype_def = Py_BuildValue("[(s, s), (s, s)]",
                              "pdp", "f8", "pdv", "f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_pvdpv);
    Py_DECREF(dtype_def);
    /* int[4] = ymdf, hmsf, dmsf */
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "y", "i4", "m", "i4", "d", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_ymdf);
    Py_DECREF(dtype_def);
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "h", "i4", "m", "i4", "s", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_hmsf);
    Py_DECREF(dtype_def);
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "h", "i4", "m", "i4", "s", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_dmsf);
    Py_DECREF(dtype_def);
    /* char1 (have to use structured, otherwise it cannot be a user type) */
    dtype_def = Py_BuildValue("[(s, s)]", "sign", "S1");
    PyArray_DescrAlignConverter(dtype_def, &dt_sign);
    Py_DECREF(dtype_def);
    /* char12 */
    dtype_def = Py_BuildValue("[(s, s)]", "type", "S12");
    PyArray_DescrAlignConverter(dtype_def, &dt_type);
    Py_DECREF(dtype_def);
    /* eraLDBODY */
    dtype_def = Py_BuildValue(
        "[(s, s), (s, s), (s, s)]",
        "bm", "f8",     /* mass of the body (solar masses) */
        "dl", "f8",     /* deflection limiter (radians^2/2) */
        "pv", "(2,3)f8" /* barycentric PV of the body (au, au/day) */
        );
    PyArray_DescrAlignConverter(dtype_def, &dt_eraLDBODY);
    Py_DECREF(dtype_def);
    /* eraASTROM */
    dtype_def = Py_BuildValue(
        "[(s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s), (s, s)]",
        "pmt", "f8",       /* PM time interval (SSB, Julian years) */
        "eb", "(3,)f8",    /* SSB to observer (vector, au) */
        "eh", "(3,)f8",    /* Sun to observer (unit vector) */
        "em", "f8",        /* distance from Sun to observer (au) */
        "v", "(3,)f8",     /* barycentric observer velocity (vector, c) */
        "bm1", "f8",       /* sqrt(1-|v|^2): reciprocal of Lorenz factor */
        "bpn", "(3,3)f8",  /* bias-precession-nutation matrix */
        "along", "f8",     /* longitude + s' + dERA(DUT) (radians) */
        "phi", "f8",       /* geodetic latitude (radians) */
        "xpl", "f8",       /* polar motion xp wrt local meridian (radians) */
        "ypl", "f8",       /* polar motion yp wrt local meridian (radians) */
        "sphi", "f8",      /* sine of geodetic latitude */
        "cphi", "f8",      /* cosine of geodetic latitude */
        "diurab", "f8",    /* magnitude of diurnal aberration vector */
        "eral", "f8",      /* "local" Earth rotation angle (radians) */
        "refa", "f8",      /* refraction constant A (radians) */
        "refb", "f8"       /* refraction constant B (radians) */
        );
    PyArray_DescrAlignConverter(dtype_def, &dt_eraASTROM);
    Py_DECREF(dtype_def);
    /* eraLEAPSECOND */
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s)]",
                              "year", "i4", "month", "i4", "tai_utc", "f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_eraLEAPSECOND);
    Py_DECREF(dtype_def);

    if (dt_double == NULL || dt_int == NULL ||
        dt_pv == NULL || dt_pvdpv == NULL ||
        dt_ymdf == NULL || dt_hmsf == NULL || dt_dmsf == NULL ||
        dt_sign == NULL || dt_type == NULL ||
        dt_eraLDBODY == NULL || dt_eraASTROM == NULL ||
        dt_eraLEAPSECOND == NULL) {
        goto fail;
    }
    /* Make the structured dtypes available in the module */
    PyDict_SetItemString(d, "dt_pv", (PyObject *)dt_pv);
    PyDict_SetItemString(d, "dt_pvdpv", (PyObject *)dt_pvdpv);
    PyDict_SetItemString(d, "dt_ymdf", (PyObject *)dt_ymdf);
    PyDict_SetItemString(d, "dt_hmsf", (PyObject *)dt_hmsf);
    PyDict_SetItemString(d, "dt_dmsf", (PyObject *)dt_dmsf);
    PyDict_SetItemString(d, "dt_sign", (PyObject *)dt_sign);
    PyDict_SetItemString(d, "dt_type", (PyObject *)dt_type);
    PyDict_SetItemString(d, "dt_eraLDBODY", (PyObject *)dt_eraLDBODY);
    PyDict_SetItemString(d, "dt_eraASTROM", (PyObject *)dt_eraASTROM);
    PyDict_SetItemString(d, "dt_eraLEAPSECOND", (PyObject *)dt_eraLEAPSECOND);
    /*
     * Define the ufuncs.  For those without structured dtypes,
     * the ufunc creation uses the static variables defined above;
     * for those with structured dtypes, an empty ufunc is created,
     * and then a userloop is added.  For both, we set the type
     * resolver to our own, and then add the ufunc to the module.
     *
     * Note that for the arguments, any inout arguments, i.e., those
     * that are changed in-place in the ERFA function, are repeated,
     * since we want the ufuncs not to do in-place changes (unless
     * explicitly requested with ufunc(..., in,..., out=in))
     */
    {%- for func in funcs %}
    {%- if not func.user_dtype %}
    ufunc = (PyUFuncObject *)PyUFunc_FromFuncAndDataAndSignature(
        funcs_{{ func.pyname }}, data, types_{{ func.pyname }},
        1, {{ func.args_by_inout('in|inout')|count }}, {{ func.args_by_inout('inout|out|ret|stat')|count }}, PyUFunc_None,
        "{{ func.pyname }}",
        "UFunc wrapper for {{ func.name }}",
        0, {% if func.signature -%} "{{ func.signature }}" {%- else -%} NULL {%- endif -%});
    if (ufunc == NULL) {
        goto fail;
    }
    {%- else %}
    ufunc = (PyUFuncObject *)PyUFunc_FromFuncAndDataAndSignature(
        NULL, NULL, NULL,
        0, {{ func.args_by_inout('in|inout')|count }}, {{ func.args_by_inout('inout|out|ret|stat')|count }}, PyUFunc_None,
        "{{ func.pyname }}",
        "UFunc wrapper for {{ func.name }}",
        0, {% if func.signature -%} "{{ func.signature }}" {%- else -%} NULL {%- endif -%});
    if (ufunc == NULL) {
        goto fail;
    }
    {%- for arg in func.args_by_inout('in|inout') %}
    dtypes[{{ loop.index - 1 }}] = {{ arg.dtype }};
    {%- endfor %}
    {%- for arg in func.args_by_inout('inout|out|ret|stat') %}
    dtypes[{{ loop.index - 1 + func.args_by_inout('in|inout')|count }}] = {{ arg.dtype }};
    {%- endfor %}
    status = PyUFunc_RegisterLoopForDescr(
        ufunc, {{ func.user_dtype }},
        ufunc_loop_{{ func.pyname }}, dtypes, NULL);
    if(status != 0){
        Py_DECREF(ufunc);
        goto fail;
    }
    {%- endif %}
    ufunc->type_resolver = &ErfaUFuncTypeResolver;
    PyDict_SetItemString(d, "{{ func.pyname }}", (PyObject *)ufunc);
    Py_DECREF(ufunc);
    {%- endfor %}

    goto decref;

fail:
    Py_XDECREF(m);
    m = NULL;

decref:
    Py_XDECREF(dt_double);
    Py_XDECREF(dt_int);
    Py_XDECREF(dt_pv);
    Py_XDECREF(dt_pvdpv);
    Py_XDECREF(dt_ymdf);
    Py_XDECREF(dt_hmsf);
    Py_XDECREF(dt_dmsf);
    Py_XDECREF(dt_sign);
    Py_XDECREF(dt_type);
    Py_XDECREF(dt_eraASTROM);
    Py_XDECREF(dt_eraLDBODY);
    Py_XDECREF(dt_eraLEAPSECOND);
    return m;
}
