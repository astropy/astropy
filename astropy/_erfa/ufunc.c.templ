/* -*- mode: c -*- */

/* Licensed under a 3-clause BSD style license - see LICENSE.rst */

/*
 * "ufunc.c" is auto-generated by erfa_generator.py from the template
 * "ufunc.c.templ". Do *not* edit "ufunc.c" directly, instead edit
 * "ufunc.c.templ" and run ufunc_generator.py from the source directory
 * to update it.
 */

#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include "Python.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#include "erfa.h"

#define MODULE_DOCSTRING \
    "Ufunc wrappers of the ERFA routines.\n\n" \
    "These ufuncs vectorize the ERFA functions assuming structured dtypes\n" \
    "for vector and matrix arguments. Status codes are vectors as well.\n" \
    "Python wrappers are also provided, which convert between\n" \
    "trailing dimensions and structured dtypes where necessary,\n" \
    "and combine status codes."

/*
 * INNER LOOPS - iteratively call the erfa function for a chunk of data.
 *
 * For each argument:
 * char *<name> is the pointer to the data in memory;
 * npy_intp s_<name> is the number of bytes between successive elements;
 * <ctype> *_<name> is a correctly cast pointer to the current element;
 * (<ctype> _<name>, i.e., not a pointer, for status codes and return values)
 *
 * Notes:
 * 1. Some erfa function change elements in-place; in the ufunc, these "inout"
 *    arguments are treated as separate: data is copied from the input to the
 *    output, and the output is changed in-place by the erfa function.
 *    To reproduce the in-place behaviour, the input to the ufunc can be passed
 *    in as output as well -- as is done in the python wrapper (the copy will
 *    be omitted for this case).
 * 2. Any erfa function involving light deflection requires an struct
 *    eraLDBODY argument with a dimension that is user-defined. Those function
 *    are implemented as generalized ufuncs, with a signature in which the
 *    relevant variable is marked (i.e., '(),...,(n), (), ... -> (),...').
 *    In the inner loops, an appropriate copy is done if in the numpy array
 *    the n elements are not contiguous.
 */

{%- for func in funcs %}

static void ufunc_loop_{{ func.pyname }}(
    char **args, npy_intp *dimensions, npy_intp* steps, void* data)
{
    {#- /* index and length of loop */ #}
    npy_intp i_o;
    npy_intp n_o = *dimensions++;
    {#- /* pointer to each argument, required step size, and cast pointer */ #}
    {%- for arg in func.args_by_inout('in') %}
    char *{{ arg.name }} = *args++;
    npy_intp s_{{ arg.name }} = *steps++;
    {{ arg.ctype }} (*_{{ arg.name }}){{ arg.cshape }};
    {%- endfor -%}
    {#- /* for inout arguments, we do not need the cast pointer, since data
           is just copied anyway */ #}
    {%- for arg in func.args_by_inout('inout') %}
    char *{{ arg.name }}_in = *args++;
    npy_intp s_{{ arg.name }}_in = *steps++;
    {%- endfor -%}
    {%- for arg in func.args_by_inout('inout|out') %}
    char *{{ arg.name }} = *args++;
    npy_intp s_{{ arg.name }} = *steps++;
    {{ arg.ctype }} (*_{{ arg.name }}){{ arg.cshape }};
    {%- endfor -%}
    {#- /* not a pointer, but just value for status codes and return values */ #}
    {%- for arg in func.args_by_inout('stat|ret') %}
    char *{{ arg.name }} = *args++;
    npy_intp s_{{ arg.name }} = *steps++;
    {{ arg.ctype }} _{{ arg.name }};
    {%- endfor %}
    {#- /* for generalized ufunc, get number of elements (inner loop) */ #}
    {%- if func.signature %}
    npy_intp j;
    npy_intp nb = dimensions[0];
    npy_intp s_ib = steps[0];
    {#- /* allocate memory for copies for non-contiguous input */ #}
    int copy_b = (s_ib != sizeof(eraLDBODY));
    if (copy_b) {
        _b = PyArray_malloc(nb * sizeof(eraLDBODY));
        if (_b == NULL) {
            PyErr_NoMemory();
            return;
        }
    }
    else {
        _b = NULL;
    }
    {%- endif %}
    {#- /* Inner loop, increasing all pointers by their steps */ #}
    for (i_o = 0; i_o < n_o;
         i_o++ {%- for arg in func.args_by_inout('in|inout|out|stat|ret') -%}
             , {{ arg.name }} += s_{{ arg.name }}
             {%- endfor -%}
             {%- for arg in func.args_by_inout('inout') -%}
             , {{ arg.name }}_in += s_{{ arg.name }}_in
             {%- endfor -%}) {
        {# /* for generalized ufunc, copy b if needed (always called that way)
               and set up pointers to other input/output arguments */ -#}
        {% if func.signature -%}
        {% for arg in func.args_by_inout('in|inout|out') -%}
        {%- if arg.name == 'b' -%}
        if (copy_b) {
            char *ib = b;
            for (j = 0; j < nb; j++, ib += s_ib) {
                _b[j] = *(eraLDBODY *)ib;
            }
        }
        else {
            _b = ((eraLDBODY (*))b);
        }
        {% else -%}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        {% endif -%}
        {% endfor -%}
        {%- else -%}
        {#- /* for normal ufunc, just set up pointers to input/output arguments */ -#}
        {% for arg in func.args_by_inout('in|inout|out') -%}
        _{{ arg.name }} = (({{ arg.ctype }} (*){{ arg.cshape }}){{ arg.name }});
        {% endfor -%}
        {%- endif -%}
        {#- /* for arguments changed in-place, copy from in to out, if needed */ -#}
        {%- for arg in func.args_by_inout('inout') -%}
        if ({{ arg.name }}_in != {{ arg.name }}) {
            memcpy({{ arg.name}}, {{ arg.name }}_in, {{ arg.size }}*sizeof({{ arg.ctype }}));
        }
        {% endfor -%}
        {#- /* call the actual erfa function */ -#}
        {{ func.args_by_inout('ret|stat') |
                    map(attribute='name') |
                    surround('_', ' = ') |
                    join
        }}{{ func.name
        }}({{ func.args_by_inout('in|inout|out') |
                    map(attribute='name_for_call') |
                    join(', ') }});
        {#- /* store any return values */ #}
        {%- for arg in func.args_by_inout('ret|stat') %}
        *(({{ arg.ctype }} *){{ arg.name }}) = _{{ arg.name }};
        {%- endfor %}
    }
    {%- if func.signature %}
    if (copy_b) {
        PyArray_free(_b);
    }
    {%- endif %}
}

{%- endfor %}

/*
 * UFUNC LOOP MATCHING HELPERS
 * All but ufunc_loop_matches are copies of code needed but not exported.
 */

/*
 * Adjusted version of ufunc_loop_matches from
 * numpy/core/src/umath/ufunc_type_resolution.c.
 * Here, we special-case the structured dtype check, only allowing
 * casting of the same dtype or string.  We also do not distinguish
 * between input and output arguments for casting.
 */
static int
ufunc_loop_matches(PyUFuncObject *self,
                   PyArrayObject **op,
                   NPY_CASTING casting,
                   int *types, PyArray_Descr **dtypes)
{
    npy_intp i, nin = self->nin, nop = nin + self->nout;
    /*
     * Check if all the inputs can be cast to the types used by this function.
     */
    for (i = 0; i < nin; ++i) {
        PyArray_Descr *op_descr = PyArray_DESCR(op[i]);
        /*
         * Check for NPY_VOID with an associated struct dtype.
         */
        if (types[i] == NPY_VOID && dtypes != NULL) {
            int op_descr_type_num = op_descr->type_num;
            int dtype_elsize = dtypes[i]->elsize;
            /*
             * MHvK: we do our own check on casting, since by default
             * all items can cast to structured dtypes (see gh-11114),
             * which is not OK. So, we only allow VOID->same VOID,
             * and STRING -> VOID-of-STRING (which works well; we
             * recognize VOID-of-STRING by the dtype element size;
             * it would be rather costly to go look at dtype->fields).
             */
            if (op_descr_type_num == NPY_VOID) {
                /* allow only the same structured to structured */
                if (!PyArray_EquivTypes(op_descr, dtypes[i])) {
                    return 0;
                }
            }
            else if (dtypes[i]->elsize == 1 || dtypes[i]->elsize == 12) {
                /* string structured array; string argument is OK */
                if (!((op_descr_type_num == NPY_STRING &&
                       op_descr->elsize <= dtype_elsize) ||
                      (op_descr_type_num == NPY_UNICODE &&
                       op_descr->elsize >> 2 <= dtype_elsize))) {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        else { /* non-void function argument */
            PyArray_Descr *tmp = PyArray_DescrFromType(types[i]);
            if (tmp == NULL) {
                return -1;
            }
            if (!PyArray_CanCastTypeTo(op_descr, tmp, casting)) {
                Py_DECREF(tmp);
                return 0;
            }
            Py_DECREF(tmp);
        }
    }
    /*
     * All inputs were ok; now check casting back to the outputs.
     * MHvK: Since no casting from structured to non-structured is
     * possible, no changes needed here.
     */
    for (i = nin; i < nop; ++i) {
        if (op[i] != NULL) {
            PyArray_Descr *tmp = PyArray_DescrFromType(types[i]);
            if (tmp == NULL) {
                return -1;
            }
            if (!PyArray_CanCastTypeTo(tmp, PyArray_DESCR(op[i]),
                                       casting)) {
                Py_DECREF(tmp);
                return 0;
            }
            Py_DECREF(tmp);
        }
    }
    return 1;
}
/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since this translation function is not exported.
 */
static const char *
npy_casting_to_string(NPY_CASTING casting)
{
    switch (casting) {
        case NPY_NO_CASTING:
            return "'no'";
        case NPY_EQUIV_CASTING:
            return "'equiv'";
        case NPY_SAFE_CASTING:
            return "'safe'";
        case NPY_SAME_KIND_CASTING:
            return "'same_kind'";
        case NPY_UNSAFE_CASTING:
            return "'unsafe'";
        default:
            return "<unknown>";
    }
}

/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since not exported.
 */
static PyArray_Descr *
ensure_dtype_nbo(PyArray_Descr *type)
{
    if (PyArray_ISNBO(type->byteorder)) {
        Py_INCREF(type);
        return type;
    }
    else {
        return PyArray_DescrNewByteorder(type, NPY_NATIVE);
    }
}

/*
 * Copy from numpy/core/src/umath/ufunc_type_resolution.c,
 * since not exported.
 */
static int
set_ufunc_loop_data_types(PyUFuncObject *self, PyArrayObject **op,
                    PyArray_Descr **out_dtypes,
                    int *type_nums, PyArray_Descr **dtypes)
{
    int i, nin = self->nin, nop = nin + self->nout;

    /*
     * Fill the dtypes array.
     * For outputs,
     * also search the inputs for a matching type_num to copy
     * instead of creating a new one, similarly to preserve metadata.
     **/
    for (i = 0; i < nop; ++i) {
        if (dtypes != NULL) {
            out_dtypes[i] = dtypes[i];
            Py_XINCREF(out_dtypes[i]);
        /*
         * Copy the dtype from 'op' if the type_num matches,
         * to preserve metadata.
         */
        }
        else if (op[i] != NULL &&
                 PyArray_DESCR(op[i])->type_num == type_nums[i]) {
            out_dtypes[i] = ensure_dtype_nbo(PyArray_DESCR(op[i]));
        }
        /*
         * For outputs, copy the dtype from op[0] if the type_num
         * matches, similarly to preserve metdata.
         */
        else if (i >= nin && op[0] != NULL &&
                            PyArray_DESCR(op[0])->type_num == type_nums[i]) {
            out_dtypes[i] = ensure_dtype_nbo(PyArray_DESCR(op[0]));
        }
        /* Otherwise create a plain descr from the type number */
        else {
            out_dtypes[i] = PyArray_DescrFromType(type_nums[i]);
        }

        if (out_dtypes[i] == NULL) {
            goto fail;
        }
    }

    return 0;

fail:
    while (--i >= 0) {
        Py_DECREF(out_dtypes[i]);
        out_dtypes[i] = NULL;
    }
    return -1;
}

/*
 * UFUNC TYPE RESOLVER
 *
 * We provide our own type resolver, since the default one,
 * PyUFunc_DefaultTypeResolver from
 * numpy/core/src/umath/ufunc_type_resolution.c, has problems:
 * 1. It only looks for userloops if any of the operands have a user
 *    type, which does not work if the inputs are normal and no explicit
 *    output is given (see https://github.com/numpy/numpy/issues/11109).
 * 2. It only allows "safe" casting of inputs, which annoyingly prevents
 *    passing in a python int for int32 input.
 * The resolver below solves both, and speeds up the process by
 * explicitly assuming that a ufunc has only one function built in,
 * either a regular one or a userloop (for structured dtype).
 *
 * Combines code from linear_search_type_resolver and
 * linear_search_userloop_type_resolver from
 * numpy/core/src/umath/ufunc_type_resolution.c
 */
static int ErfaUFuncTypeResolver(PyUFuncObject *ufunc,
                                 NPY_CASTING casting,
                                 PyArrayObject **operands,
                                 PyObject *type_tup,
                                 PyArray_Descr **out_dtypes)
{
    int *types;
    PyArray_Descr **dtypes;

    if (ufunc->userloops) {
        Py_ssize_t unused_pos = 0;
        PyObject *userloop;
        PyUFunc_Loop1d *funcdata;

        if (ufunc->ntypes > 0 || PyDict_Size(ufunc->userloops) != 1) {
            goto fail;
        }
        /* No iteration needed; only one entry in dict */
        PyDict_Next(ufunc->userloops, &unused_pos, NULL, &userloop);
        funcdata = (PyUFunc_Loop1d *)PyCapsule_GetPointer(userloop, NULL);
        /* There should be only one function */
        if (funcdata->next != NULL) {
            goto fail;
        }
        types = funcdata->arg_types;
        dtypes = funcdata->arg_dtypes;
    }
    else {
        npy_intp j;
        int types_array[NPY_MAXARGS];

        if (ufunc->ntypes != 1) {
            goto fail;
        }
        /* Copy the types into an int array for matching */
        for (j = 0; j < ufunc->nargs; ++j) {
            types_array[j] = ufunc->types[j];
        }
        types = types_array;
        dtypes = NULL;
    }
    switch (ufunc_loop_matches(ufunc, operands, casting, types, dtypes)) {
    case 1:  /* Matching types */
        return set_ufunc_loop_data_types(ufunc, operands, out_dtypes,
                                         types, dtypes);
    case -1:   /* Error */
        return -1;
    }
    /* No match */
    PyErr_Format(PyExc_TypeError,
                 "ufunc '%s' not supported for the input types, and the "
                 "inputs could not be safely coerced to any supported "
                 "types according to the casting rule '%s'",
                 ufunc->name, npy_casting_to_string(casting));
    return -1;

fail:
    /* More than one loop or function */
    PyErr_Format(PyExc_RuntimeError,
                 "Unexpected internal error: ufunc '%s' wraps an ERFA "
                 "function and should have only a single loop with a "
                 "single function, yet has more.",
                 ufunc->name);
    return -1;
}

/*
 * UFUNC MODULE DEFINITIONS AND INITIALIZATION
 */
static PyMethodDef ErfaUFuncMethods[] = {
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "ufunc",
    MODULE_DOCSTRING,
    -1,
    ErfaUFuncMethods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_ufunc(void)
{
    /* module and its dict */
    PyObject *m, *d;
    /* structured dtypes and their definition */
    PyObject *dtype_def;
    PyArray_Descr *dt_double = NULL, *dt_int = NULL;
    PyArray_Descr *dt_vector = NULL, *dt_pv = NULL;
    PyArray_Descr *dt_matrix = NULL, *dt_ymdf = NULL;
    PyArray_Descr *dt_hmsf = NULL, *dt_dmsf = NULL;
    PyArray_Descr *dt_sign = NULL, *dt_type = NULL;
    PyArray_Descr *dt_eraASTROM = NULL, *dt_eraLDBODY = NULL;
    PyArray_Descr *dtypes[NPY_MAXARGS];
    /* ufuncs and their definitions */
    int status;
    PyUFuncObject *ufunc;
    static void *data[1] = {NULL};
    {#- /* for non-structured functions, define there types and functions
           as these do not get copied */ #}
    {%- for func in funcs %}
    {%- if not func.user_dtype %}
    static char types_{{ func.pyname }}[{{ func.args_by_inout('in|inout|out|ret|stat')|count }}] = { {{ func.args_by_inout('in|inout|out|ret|stat')|map(attribute='npy_type')|join(', ') }} };
    static PyUFuncGenericFunction funcs_{{ func.pyname }}[1] = { &ufunc_loop_{{ func.pyname }} };
    {%- endif %}
    {%- endfor %}

    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }
    d = PyModule_GetDict(m); /* borrowed ref. */
    if (d == NULL) {
        goto fail;
    }

    import_array();
    import_umath();
    /*
     * Define the basic and structured types used in erfa so that
     * we can use them for definitions of userloops below.
     */
    dt_double = PyArray_DescrFromType(NPY_DOUBLE);
    dt_int = PyArray_DescrFromType(NPY_INT);
    /* double[3] */
    dtype_def = Py_BuildValue("[(s, s)]", "p", "(3,)f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_vector);
    Py_DECREF(dtype_def);
    /* double[2][3] = pv */
    dtype_def = Py_BuildValue("[(s, s), (s, s)]",
                              "p", "(3,)f8", "v", "(3,)f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_pv);
    Py_DECREF(dtype_def);
    /* double[3][3] */
    dtype_def = Py_BuildValue("[(s, s)]", "r", "(3,3)f8");
    PyArray_DescrAlignConverter(dtype_def, &dt_matrix);
    Py_DECREF(dtype_def);
    /* int[4] = ymdf, hmsf, dmsf */
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "y", "i4", "m", "i4", "d", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_ymdf);
    Py_DECREF(dtype_def);
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "h", "i4", "m", "i4", "s", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_hmsf);
    Py_DECREF(dtype_def);
    dtype_def = Py_BuildValue("[(s, s), (s, s), (s, s), (s, s)]",
                              "h", "i4", "m", "i4", "s", "i4", "f", "i4");
    PyArray_DescrAlignConverter(dtype_def, &dt_dmsf);
    Py_DECREF(dtype_def);
    /* char1 (have to use structured, otherwise it cannot be a user type) */
    dtype_def = Py_BuildValue("[(s, s)]", "sign", "S1");
    PyArray_DescrAlignConverter(dtype_def, &dt_sign);
    Py_DECREF(dtype_def);
    /* char12 */
    dtype_def = Py_BuildValue("[(s, s)]", "type", "S12");
    PyArray_DescrAlignConverter(dtype_def, &dt_type);
    Py_DECREF(dtype_def);
    /* eraLDBODY */
    dtype_def = Py_BuildValue(
        "[(s, s), (s, s), (s, s)]",
        "bm", "f8",     /* mass of the body (solar masses) */
        "dl", "f8",     /* deflection limiter (radians^2/2) */
        "pv", "(2,3)f8" /* barycentric PV of the body (au, au/day) */
        );
    PyArray_DescrAlignConverter(dtype_def, &dt_eraLDBODY);
    Py_DECREF(dtype_def);
    /* eraASTROM */
    dtype_def = Py_BuildValue(
        "[(s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s),"
        " (s, s), (s, s), (s, s), (s, s), (s, s)]",
        "pmt", "f8",       /* PM time interval (SSB, Julian years) */
        "eb", "(3,)f8",    /* SSB to observer (vector, au) */
        "eh", "(3,)f8",    /* Sun to observer (unit vector) */
        "em", "f8",        /* distance from Sun to observer (au) */
        "v", "(3,)f8",     /* barycentric observer velocity (vector, c) */
        "bm1", "f8",       /* sqrt(1-|v|^2): reciprocal of Lorenz factor */
        "bpn", "(3,3)f8",  /* bias-precession-nutation matrix */
        "along", "f8",     /* longitude + s' + dERA(DUT) (radians) */
        "phi", "f8",       /* geodetic latitude (radians) */
        "xpl", "f8",       /* polar motion xp wrt local meridian (radians) */
        "ypl", "f8",       /* polar motion yp wrt local meridian (radians) */
        "sphi", "f8",      /* sine of geodetic latitude */
        "cphi", "f8",      /* cosine of geodetic latitude */
        "diurab", "f8",    /* magnitude of diurnal aberration vector */
        "eral", "f8",      /* "local" Earth rotation angle (radians) */
        "refa", "f8",      /* refraction constant A (radians) */
        "refb", "f8"       /* refraction constant B (radians) */
        );
    PyArray_DescrAlignConverter(dtype_def, &dt_eraASTROM);
    Py_DECREF(dtype_def);
    if (dt_double == NULL || dt_vector == NULL ||
        dt_pv == NULL || dt_matrix == NULL ||
        dt_int == NULL || dt_ymdf == NULL ||
        dt_hmsf == NULL || dt_dmsf == NULL ||
        dt_sign == NULL || dt_type == NULL ||
        dt_eraLDBODY == NULL || dt_eraASTROM == NULL) {
        goto fail;
    }
    /* Make the structured dtypes available in the module */
    PyDict_SetItemString(d, "dt_vector", (PyObject *)dt_vector);
    PyDict_SetItemString(d, "dt_pv", (PyObject *)dt_pv);
    PyDict_SetItemString(d, "dt_matrix", (PyObject *)dt_matrix);
    PyDict_SetItemString(d, "dt_ymdf", (PyObject *)dt_ymdf);
    PyDict_SetItemString(d, "dt_hmsf", (PyObject *)dt_hmsf);
    PyDict_SetItemString(d, "dt_dmsf", (PyObject *)dt_dmsf);
    PyDict_SetItemString(d, "dt_sign", (PyObject *)dt_sign);
    PyDict_SetItemString(d, "dt_type", (PyObject *)dt_type);
    PyDict_SetItemString(d, "dt_eraLDBODY", (PyObject *)dt_eraLDBODY);
    PyDict_SetItemString(d, "dt_eraASTROM", (PyObject *)dt_eraASTROM);
    /*
     * Define the ufuncs.  For those without structured dtypes,
     * the ufunc creation uses the static variables defined above;
     * for those with structured dtypes, an empty ufunc is created,
     * and then a userloop is added.  For both, we set the type
     * resolver to our own, and then add the ufunc to the module.
     *
     * Note that for the arguments, any inout arguments, i.e., those
     * that are changed in-place in the ERFA function, are repeated,
     * since we want the ufuncs not to do in-place changes (unless
     * explicitly requested with ufunc(..., in,..., out=in))
     */
    {%- for func in funcs %}
    {%- if not func.user_dtype %}
    ufunc = (PyUFuncObject *)PyUFunc_FromFuncAndData(
        funcs_{{ func.pyname }}, data, types_{{ func.pyname }},
        1, {{ func.args_by_inout('in|inout')|count }}, {{ func.args_by_inout('inout|out|ret|stat')|count }}, PyUFunc_None,
        "{{ func.pyname }}",
        "UFunc wrapper for {{ func.name }}", 0);
    if (ufunc == NULL) {
        goto fail;
    }
    {%- else %}
    ufunc = (PyUFuncObject *)PyUFunc_FromFuncAndDataAndSignature(
        NULL, NULL, NULL,
        0, {{ func.args_by_inout('in|inout')|count }}, {{ func.args_by_inout('inout|out|ret|stat')|count }}, PyUFunc_None,
        "{{ func.pyname }}",
        "UFunc wrapper for {{ func.name }}",
        0, {% if func.signature -%} "{{ func.signature }}" {%- else -%} NULL {%- endif -%});
    if (ufunc == NULL) {
        goto fail;
    }
    {%- for arg in func.args_by_inout('in|inout') %}
    dtypes[{{ loop.index - 1 }}] = {{ arg.dtype }};
    {%- endfor %}
    {%- for arg in func.args_by_inout('inout|out|ret|stat') %}
    dtypes[{{ loop.index - 1 + func.args_by_inout('in|inout')|count }}] = {{ arg.dtype }};
    {%- endfor %}
    status = PyUFunc_RegisterLoopForDescr(
        ufunc, {{ func.user_dtype }},
        ufunc_loop_{{ func.pyname }}, dtypes, NULL);
    if(status != 0){
        Py_DECREF(ufunc);
        goto fail;
    }
    {%- endif %}
    ufunc->type_resolver = &ErfaUFuncTypeResolver;
    PyDict_SetItemString(d, "{{ func.pyname }}", (PyObject *)ufunc);
    Py_DECREF(ufunc);
    {%- endfor %}

    goto decref;

fail:
    Py_XDECREF(m);
    m = NULL;

decref:
    Py_XDECREF(dt_double);
    Py_XDECREF(dt_int);
    Py_XDECREF(dt_vector);
    Py_XDECREF(dt_pv);
    Py_XDECREF(dt_matrix);
    Py_XDECREF(dt_ymdf);
    Py_XDECREF(dt_hmsf);
    Py_XDECREF(dt_dmsf);
    Py_XDECREF(dt_sign);
    Py_XDECREF(dt_type);
    Py_XDECREF(dt_eraASTROM);
    Py_XDECREF(dt_eraLDBODY);
    return m;
}
