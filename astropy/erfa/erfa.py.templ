# Licensed under a 3-clause BSD style license - see LICENSE.rst

# "erfa.pyx" is auto-generated by cython_generator.py from the template
# "erfa.pyx.templ". Do *not* edit erfa.pyx directly, instead edit the template
# and run cython_generator.py from the source directory to update it.

"""
This module uses Cython to wrap the ERFA library in numpy-vectorized
equivalents.

..warning::
    This is currently *not* part of the public Astropy API, and may change in
    the future.


The key idea is that any function can be called with inputs that are arrays,
and the wrappers will automatically vectorize and call the ERFA functions for
each item using broadcasting rules for numpy.  So the return values are always
numpy arrays of some sort.

For ERFA functions that take/return vectors or matricies, the vector/matrix
dimension(s) are always the *last* dimension(s).  For example, if you
want to give ten matricies (i.e., the ERFA input type is double[3][3]),
you would pass in a (10, 3, 3) numpy array.  If the output of the ERFA
function is scalar, you'll get back a length-10 1D array.
"""
from __future__ import (absolute_import, division, print_function)

import warnings
from distutils.version import LooseVersion

from ..utils.exceptions import AstropyUserWarning

import numpy
from . import _erfa

NPYLT18 = LooseVersion(numpy.__version__) < LooseVersion('1.8')
# TODO: remove the above variable and the code using it and make_outputs_scalar when numpy < 1.8 is no longer supported

__all__ = ['ErfaError', 'ErfaWarning',
           {{ funcs|map(attribute='pyname')|surround("'","'")|join(", ") }}, 'dt_eraASTROM', 'dt_eraLDBODY']


#<---------------------------------Error-handling----------------------------->

class ErfaError(ValueError):
    """
    A class for errors triggered by ERFA functions (status codes < 0)
    """


class ErfaWarning(AstropyUserWarning):
    """
    A class for warnings triggered by ERFA functions (status codes > 0)
    """


STATUS_CODES = {}  # populated below before each function that returns an int

def check_errwarn(statcodes, func_name):
    if numpy.any(statcodes<0):
        # errors present - only report the errors.
        if statcodes.shape:
            statcodes = statcodes[statcodes<0]

        errcodes = numpy.unique(statcodes)

        errcounts = dict([(e, numpy.sum(statcodes==e)) for e in errcodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, 'Return code ' + str(e))) for e in errcodes])
        else:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, elsemsg)) for e in errcodes])

        emsg = ', '.join(['{0} of "{1}"'.format(errcounts[e], errmsgs[e]) for e in errcodes])
        raise ErfaError('ERFA function "' + func_name + '" yielded ' + emsg)

    elif numpy.any(statcodes>0):
        #only warnings present
        if statcodes.shape:
            statcodes = statcodes[statcodes>0]

        warncodes = numpy.unique(statcodes)

        warncounts = dict([(w, numpy.sum(statcodes==w)) for w in warncodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, 'Return code ' + str(w))) for w in warncodes])
        else:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, elsemsg)) for w in warncodes])

        wmsg = ', '.join(['{0} of "{1}"'.format(warncounts[w], warnmsgs[w]) for w in warncodes])
        warnings.warn('ERFA function "' + func_name + '" yielded ' + wmsg, ErfaWarning)


#<-------------------------trailing shape verification------------------------>

def check_trailing_shape(arr, shape, name):
    try:
        if arr.shape[-len(shape):] != shape:
            raise Exception()
    except:
        raise ValueError("{0} must be of trailing dimensions {1}".format(name, shape))

#<--------------------------calculate broadcast shape------------------------->

def calculate_broadcast(in_dim, out_dim):
    in_ndim = len(in_dim)
    out_ndim = len(out_dim)
    if in_ndim > out_ndim:
    	out_dim += [1]*(in_ndim-out_ndim)
    for i in range(in_ndim):
        _in = in_dim[in_ndim - i - 1]
        _out = out_dim[i]
        if (_in != _out):
            if (_out == 1):
                out_dim[i] = _in
            elif (_in == 1):
                pass
            else:
                raise Exception("Input arrays are not broadcastable")

#<-----------------------------Iterator definition---------------------------->

def setup_iter(args, args_dtype, args_shape, args_name, nin):

    #Turn all inputs into arrays
    for i in range(len(args)):
        args[i] = numpy.array(args[i], dtype=args_dtype[i], order="C", copy=False, subok=True)
        if len(args_shape[i]) > 0:
            check_trailing_shape(args[i], args_shape[i], args_name[i])

    #Avoid 0d/scalars in numpy < 1.8
    make_outputs_scalar = False
    if NPYLT18:
        make_outputs_scalar = True
        for i in range(len(args)):
            if args[i].shape == tuple():
                args[i] = args[i].reshape((1,)+args_shape[i])
            else:
                make_outputs_scalar = False

    #Create the output array, based on the broadcasted shape, adding the generated dimensions if needed
    iter_shape = []
    for i in range(len(args)):
        calculate_broadcast(args[i].shape[:len(args[i].shape)-len(args_shape[i])], iter_shape)
    iter_shape = iter_shape[::-1]
    for i in range(nin, len(args_dtype)):
        arg_out = numpy.empty(iter_shape + list(args_shape[i]), dtype=args_dtype[i])
        if i < len(args):
            numpy.copyto(arg_out, args[i])
            args[i] = arg_out
        else:
            args += [arg_out]

    #Create the iterator, broadcasting on all but the consumed dimensions
    op_axes = [[-1]*(len(iter_shape)-len(args[i].shape)+len(args_shape[i])) + list(range(len(args[i].shape)-len(args_shape[i]))) for i in range(len(args))]
    op_flags = [['readonly']]*nin + [['readwrite']]*(len(args)-nin)
    it = numpy.nditer(args, op_axes=op_axes, op_flags=op_flags)

    return it, make_outputs_scalar

#<---------------------------------Make results------------------------------->

def make_results(args, args_name, nin, func_name, stat_ok, make_outputs_scalar):

    if not stat_ok:
        check_errwarn(args[-1], func_name)

    #Drop status code froms args
    if args_name[-1] == 'c_statval':
        args = args[:-1]

    #need to convert the outputs back to scalars if all the inputs were scalars but we made them 1d
    if make_outputs_scalar:
        for i in range(nin, len(args)):
            assert len(args[i].shape) > 0 and args[i].shape[0] == 1
            args[i] = args[i][0]

    result = args[nin:]
    if len(result) == 1:
        result = result[0]

    return result

#<--------------------------Actual ERFA-wrapping code------------------------->

dt_eraASTROM = numpy.dtype([('pmt','d'),
                         ('eb','d',(3,)),
                         ('eh','d',(3,)),
                         ('em','d'),
                         ('v','d',(3,)),
                         ('bm1','d'),
                         ('bpn','d',(3,3)),
                         ('along','d'),
                         ('phi','d'),
                         ('xpl','d'),
                         ('ypl','d'),
                         ('sphi','d'),
                         ('cphi','d'),
                         ('diurab','d'),
                         ('eral','d'),
                         ('refa','d'),
                         ('refb','d')], align=True)

dt_eraLDBODY = numpy.dtype([('bm','d'),
                         ('dl','d'),
                         ('pv','d',(2,3))], align=True)



{% for func in funcs %}
def {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}):
    """
    {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }})

    Returns: {{ func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|join(', ') }}

    ERFA documentation:
{{ func.doc }}
    """

    func_name = "{{ func.pyname }}"
    args = [{{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}]
    args_dtype = [{{ func.args_by_inout('in|inout|out|ret|stat')|map(attribute='dtype')|join(', ') }}]
    args_shape = [{{ func.args_by_inout('in|inout|out|ret|stat')|map(attribute='shape')|join(', ') }}]
    args_name = [{{ func.args_by_inout('in|inout|out|ret|stat')|map(attribute='name')|surround('"', '"')|join(', ') }}]
    nin = {{ func.args_by_inout('in')|length }}

    it, make_outputs_scalar = setup_iter(args, args_dtype, args_shape, args_name, nin)

    #Iterate
    stat_ok = _erfa._{{ func.pyname }}(it)

    return make_results(args, args_name, nin, func_name, stat_ok, make_outputs_scalar)

{%- for stat in func.args_by_inout('stat') %}
{%- if stat.doc_info.statuscodes %}
STATUS_CODES['{{ func.pyname }}'] = {{ stat.doc_info.statuscodes|string }}
{% endif %}
{%- endfor %}

{% endfor %}