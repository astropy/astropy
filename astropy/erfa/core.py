# Licensed under a 3-clause BSD style license - see LICENSE.rst

# "erfa.pyx" is auto-generated by cython_generator.py from the template
# "erfa.pyx.templ". Do *not* edit erfa.pyx directly, instead edit the template
# and run cython_generator.py from the source directory to update it.

"""
This module uses Cython to wrap the ERFA library in numpy-vectorized
equivalents.

..warning::
    This is currently *not* part of the public Astropy API, and may change in
    the future.


The key idea is that any function can be called with inputs that are arrays,
and the wrappers will automatically vectorize and call the ERFA functions for
each item using broadcasting rules for numpy.  So the return values are always
numpy arrays of some sort.

For ERFA functions that take/return vectors or matricies, the vector/matrix
dimension(s) are always the *last* dimension(s).  For example, if you
want to give ten matricies (i.e., the ERFA input type is double[3][3]),
you would pass in a (10, 3, 3) numpy array.  If the output of the ERFA
function is scalar, you'll get back a length-10 1D array.
"""

from __future__ import (absolute_import, division, print_function)

import json
import os
import warnings

from distutils.version import LooseVersion
from functools import update_wrapper

from ..utils.codegen import make_function_with_signature
from ..utils.exceptions import AstropyUserWarning
from ..modeling.utils import check_broadcast

import numpy as np
from . import _core

NPYLT18 = LooseVersion(np.__version__) < LooseVersion('1.8')
# TODO: remove the above variable and the code using it and make_outputs_scalar
# when numpy < 1.8 is no longer supported

__all__ = ['ErfaError', 'ErfaWarning', 'dt_eraASTROM', 'dt_eraLDBODY']



class ErfaError(ValueError):
    """
    A class for errors triggered by ERFA functions (status codes < 0)
    """


class ErfaWarning(AstropyUserWarning):
    """
    A class for warnings triggered by ERFA functions (status codes > 0)
    """


STATUS_CODES = {}  # populated below before each function that returns an int


dt_eraASTROM = np.dtype([('pmt','d'),
                         ('eb','d',(3,)),
                         ('eh','d',(3,)),
                         ('em','d'),
                         ('v','d',(3,)),
                         ('bm1','d'),
                         ('bpn','d',(3,3)),
                         ('along','d'),
                         ('phi','d'),
                         ('xpl','d'),
                         ('ypl','d'),
                         ('sphi','d'),
                         ('cphi','d'),
                         ('diurab','d'),
                         ('eral','d'),
                         ('refa','d'),
                         ('refb','d')], align=True)


dt_eraLDBODY = np.dtype([('bm','d'),
                         ('dl','d'),
                         ('pv','d',(2,3))], align=True)


CTYPE_TO_DTYPE = {
    'double'     : np.double,
    'int'        : np.intc,
    'eraASTROM'  : dt_eraASTROM,
    'eraLDBODY'  : dt_eraLDBODY,
    'char'       : np.dtype('S16'),
    'const char' : np.dtype('S16'),
}


def check_errwarn(statcodes, func_name):
    """
    For functions that return status codes, either raise an exception if
    any of the status codes were error codes, or issue a warning for any
    status codes that are warnings.
    """

    def generate_message(statcodes):
        errcodes = np.unique(statcodes)

        errcounts = dict((e, np.sum(statcodes==e)) for e in errcodes)

        stat_msgs = STATUS_CODES[func_name]

        elsemsg = STATUS_CODES[func_name].get('else')

        if elsemsg is None:
            default = 'Return code {0}'
            errmsgs = dict((e, stat_msgs.get(str(e), default.format(e)))
                           for e in errcodes)
        else:
            errmsgs = dict((e, stat_msgs.get(e, elsemsg)) for e in errcodes)

        return ', '.join('{0} of "{1}"'.format(errcounts[e], errmsgs[e])
                         for e in errcodes)

    if np.any(statcodes < 0):
        # errors present - only report the errors.
        if statcodes.shape:
            statcodes = statcodes[statcodes < 0]

        err_msg = generate_message(statcodes)
        raise ErfaError(
            "ERFA function '{0}' yielded {1}".format(func_name, err_msg))

    elif np.any(statcodes > 0):
        # only warnings present
        if statcodes.shape:
            statcodes = statcodes[statcodes > 0]

        warn_msg = generate_message(statcodes)
        warnings.warn(
            "ERFA function '{0}' yielded {1}".format(func_name, warn_msg),
            ErfaWarning)


def make_erfa_func(func_name, func_meta):
    """
    Given the (Python) function name for an ERFA function, and the function's
    metadata as read out of the ``erfa.json`` file, returns a Python function
    with the name and argument signature matching the related ERFA function
    and that prepares the user's arguments for the vectorized implementation
    of that function.
    """

    def erfa_func(*args):
        return erfa_func_wrapper(func_name, func_meta, *args)

    erfa_func.__doc__ = func_meta['doc']

    func_args = tuple(arg['name'] for arg in func_meta['arguments']
                      if arg['direction'] in ('in', 'inout'))

    erfa_func = make_function_with_signature(erfa_func, args=func_args,
                                             name=func_name)

    # Add status codes to the STATUS_CODES mapping if this function returns a
    # status
    statuscodes = func_meta.get('statuscodes')
    if statuscodes:
        STATUS_CODES[func_name] = statuscodes

    return erfa_func


def erfa_func_wrapper(func_name, func_meta, *args):
    """
    A wrapper for the C/Cython vectorized versions of the ERFA functions.

    This wrapper checks all input arguments and prepares input/output arrays
    for the vectorized versions of the ERFA functions, then executes the
    associated C loop.
    """

    iter_args = []

    iter_shape = ()
    arg_meta = func_meta['arguments']
    make_outputs_scalar = NPYLT18

    #Turn all inputs into arrays
    for idx, (arg, meta) in enumerate(zip(args, arg_meta)):
        arg = np.array(arg, dtype=CTYPE_TO_DTYPE[meta['ctype']],
                       order='C', copy=False, subok=True)
        # The JSON structure returns lists instead of tuples, so make sure
        # to return a tuple
        # TODO: Might consider a custom JSONDecoder that uses the correct
        # types for this data structure
        shape = tuple(meta.get('shape', ()))
        if shape:
            if arg.shape[-len(shape):] != shape:
                raise ValueError(
                    "{0} must be of trailing dimensions "
                    "{1}".format(func_name, shape))

        if NPYLT18:
            # in numpy < 1.8, the iterator used below doesn't work with 0d/scalar arrays
            # so we replace all scalars with 1d arrays
            if arg.shape == shape:
                arg = arg[np.newaxis]
            else:
                # If any of the arguments are not scalar than we will be
                # broadcasting, so no sense in forcing scalar output
                make_outputs_scalar = False

        iter_shape = check_broadcast(arg.shape[:len(arg.shape) - len(shape)],
                                     iter_shape)
        iter_args.append(arg)

    n_in = len([m for m in arg_meta if m['direction'] == 'in'])
    # Now that we've prepared the inputs, let's prepare the output arrays
    # For inout arguments the input is copied to a new output array
    for idx, meta in enumerate(arg_meta[n_in:]):
        out_arg = np.empty(iter_shape + tuple(meta.get('shape', ())),
                           dtype=CTYPE_TO_DTYPE[meta['ctype']])
        if meta['direction'] == 'inout':
            np.copyto(out_arg, args[n_in + idx])

        iter_args.append(out_arg)

    # Add an array for the return value if there is one
    ret_type = func_meta.get('return')
    if ret_type:
        iter_args.append(np.empty(iter_shape, dtype=CTYPE_TO_DTYPE[ret_type]))


    #Create the iterator, broadcasting on all but the consumed dimensions
    op_axes = [compute_op_axes(iter_args[idx], iter_shape,
                               arg_meta[idx].get('shape', ()))
               for idx in range(len(iter_args[:-1]))]
    op_axes.append(compute_op_axes(iter_args[-1], iter_shape, ()))

    # The number of readwrite flags is the number of inout arguments
    # (i.e. the number of all arguments minus the arguments that are strictly
    #  input, `n_in`)
    op_flags = [['readonly']]*n_in + [['readwrite']]*(len(iter_args) - n_in)
    it = np.nditer(iter_args, op_axes=op_axes, op_flags=op_flags)

    #Iterate
    stat_ok = getattr(_core, '_' + func_name)(it)

    if not stat_ok:
        # This *only* should ever return False for functions that return a
        # status code in the first place.  For functions that don't return a
        # status code the default status is OK
        check_errwarn(iter_args[-1], func_name)

    if 'statuscodes' in func_meta:
        # The last array represents the status code, which we don't return
        iter_args = iter_args[:-1]

    results = iter_args[n_in:]

    if make_outputs_scalar:
        for idx, arr in enumerate(results):
            assert arr.shape[:1] == (1,)
            results[idx] = arr.reshape(arr.shape[1:])

    if len(results) == 1:
        return results[0]

    return tuple(results)


def compute_op_axes(arr, iter_shape, arg_shape):
    """
    Determine the correct op_axes argument to `numpy.nditer`.

    TODO: This should be explained better and/or simplified.
    """

    broadcast_axes = [-1] * (len(iter_shape) - len(arr.shape) +
                             len(arg_shape))

    return broadcast_axes + list(range(len(iter_shape) - len(broadcast_axes)))


DEFAULT_ERFA_FUNCS = os.path.join(os.path.dirname(__file__,), 'erfa.json')


def make_erfa_functions(source_file=DEFAULT_ERFA_FUNCS):
    """
    Read all metadata about known ERFA functions from ``source_file``
    (defaulting to the generated ``erfa.json`` file in the same directory as
    this source file) and create the associated Python functions.
    """

    # TODO: Add some error handling here in the off chance the erfa.json can't
    # be found or is corrupt :/

    with open(source_file) as fp:
        functions = {}
        func_info = json.load(fp)

    for func_name, func_meta in func_info.items():
        functions[func_name] = make_erfa_func(func_name, func_meta)

    return functions


def _init_module():
    """
    Generate all the ERFA functions and add them to this module's globals.
    """

    # TODO: We might be able to create a special ModuleType for the erfa module
    # that just generates these functions on demand and use an import hook to
    # add it to sys.modules

    erfa_functions = make_erfa_functions()
    globals().update(erfa_functions)
    __all__.extend(sorted(erfa_functions.keys()))


_init_module()
