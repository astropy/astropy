/* Licensed under a 3-clause BSD style license - see LICENSE.rst

  "erfa.c" is auto-generated by cython_generator.py from the template
  "erfa.c.templ". Do *not* edit erfa.c directly, instead edit the template
  and run cython_generator.py from the source directory to update it.
*/

#include <Python.h>

#include <numpy/arrayobject.h>

#include "erfa.h"


const char *module_docstring =
    "This module uses Cython to wrap the ERFA library in numpy-vectorized\n"
    "equivalents.\n"
    "\n"
    "..warning::\n"
    "    This is currently *not* part of the public Astropy API, and may change in\n"
    "    the future.\n"
    "\n"
    "The key idea is that any function can be called with inputs that are arrays,\n"
    "and the wrappers will automatically vectorize and call the ERFA functions for\n"
    "each item using broadcasting rules for numpy.  So the return values are always\n"
    "numpy arrays of some sort.\n"
    "\n"
    "For ERFA functions that take/return vectors or matricies, the vector/matrix\n"
    "dimension(s) are always the *last* dimension(s).  For example, if you\n"
    "want to give ten matricies (i.e., the ERFA input type is double[3][3]),\n"
    "you would pass in a (10, 3, 3) numpy array.  If the output of the ERFA\n"
    "function is scalar, you'll get back a length-10 1D array.\n";


static PyArray_Descr *dt_double = NULL;
static PyArray_Descr *dt_int = NULL;
static PyArray_Descr *dt_string = NULL;
static PyArray_Descr *dt_eraASTROM = NULL;
static PyArray_Descr *dt_eraLDBODY = NULL;

static PyObject *ErfaWarning = NULL;
static PyObject *ErfaError = NULL;


static int check_trailing_shape(const int index, PyArrayObject *arr,
                                int ndim, const npy_intp *dims,
                                const char *name)
{
    int off;
    int i;
    char tmp[256];
    char buffer[256];

    off = PyArray_NDIM(arr) - ndim;
    if (off >= 0) {
        for (i = 0; i < ndim; ++i) {
            if (PyArray_DIM(arr, i + off) != dims[i]) {
                goto error;
            }
        }
        return 0;
    }

 error:
    buffer[0] = 0;
    for (i = 0; i < ndim; ++i) {
        snprintf(tmp, 255, "%d", (int)dims[i]);
        strncat(buffer, tmp, 255);
        if (i != ndim - 1) {
            strncat(buffer, ", ", 255);
        }
    }

    PyErr_Format(PyExc_ValueError,
                 "Arg %d (%s) has wrong trailing dimensions, expected [%s]",
                 i, name, buffer);
    return 1;
}


static PyObject *format_errors(int nerrors, const char **messages,
                               int *counts)
{
    int i;
    int uniques;
    PyObject *str;
    PyObject *substr;

    for (i = 0; i < nerrors; ++i) {
        if (counts[i] > 0) {
            uniques++;
        }
    }

    str = PyString_FromStringAndSize(NULL, 0);
    if (str == NULL) {
        return NULL;
    }

    for (i = 0; i < nerrors; ++i) {
        if (counts[i] > 0) {
            substr = PyString_FromFormat(
                "%d of \"%s\"", counts[i], messages[i]);
            if (substr == NULL) {
                Py_DECREF(str);
                return NULL;
            }
            PyString_ConcatAndDel(&str, substr);
            uniques--;

            if (uniques) {
                substr = PyString_FromString(", ");
                if (substr == NULL) {
                    Py_DECREF(str);
                    return NULL;
                }
                PyString_ConcatAndDel(&str, substr);
            }
        }
    }

    return str;
}


static int check_errwarn(PyArrayObject *stat, const char *name, int nerrors,
                         const char **errors, int nwarnings, const char **warnings)
{
    int i;
    int *data;
    int error_count = 0;
    int *error_counts = NULL;
    int warning_count = 0;
    int *warning_counts = NULL;
    PyObject *str;
    int result = 1;

    if (nerrors) {
        error_counts = calloc(sizeof(int), nerrors);
    }

    if (nwarnings) {
        warning_counts = calloc(sizeof(int), nwarnings);
    }

    data = PyArray_DATA(stat);
    for (i = 0; i < PyArray_SIZE(stat); ++i) {
        if (data[i] < 0) {
            error_counts[-data[i]]++;
            error_count++;
        } else if (data[i] > 0) {
            warning_counts[data[i]]++;
            warning_count++;
        }
    }

    if (error_count) {
        str = format_errors(nerrors, errors, error_counts);
        if (str == NULL) {
            goto exit;
        }
        PyErr_SetObject(ErfaError, str);
        Py_DECREF(str);
    } else if (warning_count) {
        str = format_errors(nwarnings, warnings, warning_counts);
        if (str == NULL) {
            goto exit;
        }
        PyErr_Warn(ErfaWarning, PyString_AsString(str));
        Py_DECREF(str);
        result = 0;
    } else {
        result = 0;
    }

 exit:

    free(error_counts);
    free(warning_counts);

    return result;
}


static void setup_op_axes(int iter_nd, int narrs, PyArrayObject **arrs,
                       const int *extra_axes, int **op_axes)
{
    int i;
    int j;
    int extra;
    int *axes;

    for (i = 0; i < narrs; ++i) {
        axes = malloc(sizeof(int) * iter_nd);
        extra = iter_nd - (PyArray_NDIM(arrs[i]) - extra_axes[i]);
        if (extra < 0) {
            extra = 0;
        }
        for (j = 0; j < iter_nd; ++j) {
            axes[j] = -1;
        }
        for (j = 0; j < PyArray_NDIM(arrs[i]) && j < iter_nd - extra; ++j) {
            axes[j + extra] = j;
        }
        op_axes[i] = axes;
    }
}


static int calculate_broadcast(int in_ndim, npy_intp *in_dim,
                               int *out_ndim, npy_intp *out_dim)
{
    int i;
    npy_intp in;
    npy_intp out;

    if (in_ndim > *out_ndim) {
        *out_ndim = in_ndim;
    }

    for (i = 0; i < in_ndim; ++i) {
        in = in_dim[in_ndim - i - 1];
        out = out_dim[i];
        if (in != out) {
            if (out == 1) {
                out_dim[i] = in;
            } else if (in == 1) {
                ;
            } else {
                PyErr_SetString(
                    PyExc_TypeError, "Input arrays are not broadcastable");
                return 1;
            }
        }
    }

    return 0;
}


static NpyIter *setup_iter(PyObject *args, const char *pyname, const int narrs,
                           const int nin, const int ninout, PyArrayObject **arrs,
                           PyArray_Descr **dtypes, const int *extra_axes,
                           const npy_intp *extra_axes_shape, const char **arg_names)
{
    int i, j;
    NpyIter *iter = NULL;
    PyObject *tmp;
    int *op_axes[narrs];
    npy_uint32 flags[narrs];
    int iter_nd = 0;
    npy_intp iter_shape[NPY_MAXDIMS];
    int out_nd = 0;
    npy_intp out_dims[NPY_MAXDIMS];
    const npy_intp *extra_axes_shape_p;
    PyObject *ptype;
    PyObject *pvalue;
    PyObject *ptraceback;
    PyObject *pbytes;
    char *original_message;

    for (i = 0; i < narrs; ++i) {
        arrs[i] = NULL;
        op_axes[i] = NULL;
    }

    if (PyTuple_Size(args) != ninout) {
        PyErr_Format(PyExc_TypeError,
                     "Wrong number of arguments to %s. "
                     "Expected %d, got %zd",
                     pyname, narrs, PyTuple_Size(args));
        goto exit;
    }

    for (i = 0; i < NPY_MAXDIMS; ++i) {
        iter_shape[i] = 1;
    }

    for (i = 0; i < nin; ++i) {
        flags[i] = NPY_ITER_READONLY;
    }

    for (i = nin; i < narrs; ++i) {
        flags[i] = NPY_ITER_READWRITE;
    }

    /* Turn all inputs into arrays */
    extra_axes_shape_p = extra_axes_shape;
    for (i = 0; i < ninout; ++i) {
        tmp = PyArray_FromAny(PyTuple_GET_ITEM(args, i), dtypes[i], 0,
                              NPY_MAXDIMS, NPY_C_CONTIGUOUS, 0);
        if (tmp == NULL) {
            PyErr_Fetch(&ptype, &pvalue, &ptraceback);
            pbytes = PyObject_Bytes(pvalue);
            if (pbytes == NULL) {
                original_message = "";
            } else {
                original_message = PyBytes_AsString(pbytes);
            }
            PyErr_Format(ptype, "Arg %d (%s): %s",
                         i, arg_names[i], original_message);
            Py_XDECREF(pbytes);
            goto exit;
        }
        Py_INCREF(dtypes[i]);
        arrs[i] = (PyArrayObject *)tmp;
        if (extra_axes[i] > 0) {
            if (check_trailing_shape(i, arrs[i], extra_axes[i], extra_axes_shape_p,
                                     arg_names[i])) {
                goto exit;
            }
            extra_axes_shape_p += extra_axes[i];
        }
        if (calculate_broadcast(
                PyArray_NDIM(tmp) - extra_axes[i],
                PyArray_DIMS(tmp),
                &iter_nd, iter_shape)) {
            goto exit;
        }
    }

    /* Reverse the dimensions back from how they were calculated */
    for (i = 0; i < iter_nd; ++i) {
        out_dims[iter_nd - i - 1] = iter_shape[i];
    }

    extra_axes_shape_p = extra_axes_shape;
    for (i = nin; i < narrs; ++i) {
        for (j = 0; j < extra_axes[i]; ++j) {
            out_dims[j + iter_nd] = *extra_axes_shape_p++;
        }
        out_nd = iter_nd + extra_axes[i];

        tmp = PyArray_Empty(out_nd, out_dims, dtypes[i], 0);
        if (tmp == NULL) {
            goto exit;
        }
        Py_INCREF(dtypes[i]);
        arrs[i] = (PyArrayObject *)tmp;
        if (i < ninout) {
            if (PyArray_CopyInto((PyArrayObject *)tmp, arrs[i])) {
                goto exit;
            }
            Py_DECREF(arrs[i]);
            arrs[i] = (PyArrayObject *)tmp;
        }
    }

    setup_op_axes(iter_nd, narrs, arrs, extra_axes, op_axes);

    iter = (NpyIter *)NpyIter_AdvancedNew(
        narrs, arrs, 0, NPY_KEEPORDER, NPY_NO_CASTING, flags, dtypes,
        iter_nd, op_axes, NULL, 8192);
    if (iter == NULL) {
        goto exit;
    }

 exit:

    for (i = 0; i < narrs; ++i) {
        free(op_axes[i]);
    }

    return iter;
}


static PyObject *make_result(const char *pyname, const int narrs, const int nin,
                             const int nout, const int stat_index,
                             const int stat_ok, PyArrayObject **arrs,
                             const int nerrorcodes, const char **errorcodes,
                             const int nwarningcodes, const char **warningcodes)
{
    int i;
    PyObject *result = NULL;

    if (stat_index >= 0 && !stat_ok) {
        if (check_errwarn(
                arrs[stat_index], pyname,
                nerrorcodes, errorcodes,
                nwarningcodes, warningcodes)) {
            goto exit;
        }
    }

    if (nout == 1) {
        result = (PyObject *)arrs[nin];
        Py_INCREF(result);
    } else {
        result = PyTuple_New(nout);
        if (result == NULL) {
            goto exit;
        }

        for (i = 0; i < nout; ++i) {
            Py_INCREF((PyObject *)arrs[i + nin]);
            PyTuple_SET_ITEM(result, i, (PyObject *)arrs[i + nin]);
        }
    }

 exit:

    return result;
}

{%- for func in funcs %}

char Py_{{ func.pyname }}_doc[] = {
    {{ func.doc.c_docstring }}
    0x00
};

static PyObject *Py_{{ func.pyname }}(PyObject *self, PyObject *args, PyObject *kwds)
{
    const char *pyname = "{{ func.pyname }}";
    const int narrs = {{ func.args|length }};
    PyArray_Descr *dtypes[] = {
        {%- for arg in func.args %}
        {{ arg.cdtype }},
        {%- endfor %}
    };
    const int extra_axes[] = {
        {%- for arg in func.args %}
        {{ arg.ndim }},
        {%- endfor %}
    };
    const npy_intp extra_axes_shape[] = {
        {%- for arg in func.args %}
        {%- for x in arg.shape %}
        {{ x }},
        {%- endfor %}
        {%- endfor %}
    };
    const char *arg_names[] = {
        {%- for arg in func.args %}
        "{{ arg.name }}",
        {%- endfor %}
    };
    PyArrayObject *arrs[narrs];
    const int nin = {{ func.args_by_inout('in')|length }};
    const int ninout = {{ func.args_by_inout('in|inout')|length }};
    const int nout = {{ func.args_by_inout('inout|out|ret')|length }};

    {%- if func.args_by_inout('stat')|length %}
    {%- for stat in func.args_by_inout('stat') %}
    const int nerrorcodes = {{ stat.doc_info.errorcodes|length }};
    const char *errorcodes[] = {
        {%- for code in stat.doc_info.errorcodes %}
        "{{ code }}",
        {%- endfor %}
    };
    const int nwarningcodes = {{ stat.doc_info.warningcodes|length }};
    const char *warningcodes[] = {
        {%- for code in stat.doc_info.warningcodes %}
        "{{ code }}",
        {%- endfor %}
    };
    const int stat_index = {{ func.args.index(stat) }};
    {%- endfor %}
    {%- else %}
    const int stat_index = -1;
    const int nerrorcodes = 0;
    const char *errorcodes[] = {};
    const int nwarningcodes = 0;
    const char *warningcodes[] = {};
    {%- endif %}
    {%- for arg in func.args %}
    {{ arg.ctype_ptr }} _{{ arg.name }};
    {%- endfor %}

    int i;
    int stat_ok = 1;
    NpyIter *iter = NULL;
    NpyIter_IterNextFunc *iternext = NULL;
    char **data;
    PyObject *result = NULL;

    iter = setup_iter(args, pyname, narrs, nin, ninout, arrs, dtypes,
                      extra_axes, extra_axes_shape, arg_names);
    if (iter == NULL) {
        goto exit;
    }

    iternext = NpyIter_GetIterNext(iter, NULL);
    data = NpyIter_GetDataPtrArray(iter);

    do {
        {%- for arg in func.args_by_inout('in|inout|out') %}
        _{{ arg.name }} = (({{ arg.ctype }} *)(data[{{ func.args.index(arg) }}])){%- if arg.ctype_ptr[-1] != '*' %}[0]{% endif %};
        {%- endfor %}
        {{ func.args_by_inout('ret|stat')|map(attribute='name')|surround('_',' = ')|join }}{{ func.name }}({{ func.args_by_inout('in|inout|out')|map(attribute='name')|prefix('_')|join(', ') }});
        {%- for arg in func.args_by_inout('ret|stat') %}
        (({{ arg.ctype }} *)(data[{{ func.args.index(arg) }}]))[0] = _{{ arg.name }};
        {%- endfor %}
        {%- for arg in func.args_by_inout('stat') %}
        if (_{{ arg.name }} != 0) {
            stat_ok = 0;
        }
        {%- endfor %}
    } while (iternext(iter));

    if (NpyIter_Deallocate(iter) != NPY_SUCCEED) {
        goto exit;
    }
    iter = NULL;

    result = make_result(pyname, narrs, nin, nout, stat_index, stat_ok, arrs,
                         nerrorcodes, errorcodes, nwarningcodes, warningcodes);

 exit:

    for (i = 0; i < narrs; ++i) {
        Py_XDECREF(arrs[i]);
    }

    return result;
}

{%- endfor %}

static PyMethodDef module_functions[] = {
    {%- for func in funcs %}
    { "{{ func.pyname }}", (PyCFunction)Py_{{ func.pyname }}, METH_VARARGS, Py_{{ func.pyname }}_doc },
    {%- endfor %}
    { NULL }
};


struct module_state
{
    int _dummy;
};

#if PY3K
static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "_erfa",
    module_docstring,
    sizeof(struct module_state),
    module_functions,
    NULL,
    NULL,
    NULL,
    NULL
};

#define INITERROR return NULL

PyMODINIT_FUNC PyInit__erfa(void)

#else
#define INITERROR return

PyMODINIT_FUNC init_erfa(void)
#endif

{
    PyObject *m;
    PyObject *tmp;
    PyObject *dict;
    PyObject *astropy_utils_exceptions;
    PyObject *astropy_userwarning;

#if PY3K
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule3("_erfa", module_functions, module_docstring);
#endif

    if (m == NULL) {
        INITERROR;
    }

    import_array();

    tmp = PyBytes_FromString("f8");
    if (tmp == NULL) {
        INITERROR;
    }
    if (!PyArray_DescrConverter(tmp, &dt_double)) {
        INITERROR;
    }
    Py_DECREF(tmp);

    tmp = PyBytes_FromString("intc");
    if (tmp == NULL) {
        INITERROR;
    }
    if (!PyArray_DescrConverter(tmp, &dt_int)) {
        INITERROR;
    }
    if (dt_int == NULL) {
        INITERROR;
    }
    Py_DECREF(tmp);

    tmp = PyBytes_FromString("S16");
    if (tmp == NULL) {
        INITERROR;
    }
    if (!PyArray_DescrConverter(tmp, &dt_string)) {
        INITERROR;
    }
    Py_DECREF(tmp);

    dict = PyDict_New();
    if (dict == NULL) {
        INITERROR;
    }

    tmp = PyRun_String(
        "[('pmt','d'),('eb','d',(3,)),('eh','d',(3,)),('em','d'),('v','d',(3,)),('bm1','d'),('bpn','d',(3,3)),('along','d'),('phi','d'),('xpl','d'),('ypl','d'),('sphi','d'),('cphi','d'),('diurab','d'),('eral','d'),('refa','d'),('refb','d')]", Py_eval_input, dict, dict);
    if (tmp == NULL) {
        INITERROR;
    }
    if (!PyArray_DescrAlignConverter(tmp, &dt_eraASTROM)) {
        INITERROR;
    }
    Py_DECREF(tmp);
    if (PyModule_AddObject(m, "dt_eraASTROM", (PyObject *)dt_eraASTROM)) {
        INITERROR;
    }

    tmp = PyRun_String(
        "[('bm','d'),('dl','d'),('pv','d',(2,3))]", Py_eval_input, dict, dict);
    if (tmp == NULL) {
        INITERROR;
    }
    if (!PyArray_DescrAlignConverter(tmp, &dt_eraLDBODY)) {
        INITERROR;
    }
    Py_DECREF(tmp);
    if (PyModule_AddObject(m, "dt_eraLDBODY", (PyObject *)dt_eraLDBODY)) {
        INITERROR;
    }

    astropy_utils_exceptions = PyImport_ImportModule("astropy.utils.exceptions");
    if (astropy_utils_exceptions == NULL) {
        INITERROR;
    }
    astropy_userwarning = PyObject_GetAttrString(
        astropy_utils_exceptions, "AstropyUserWarning");
    if (astropy_userwarning == NULL) {
        INITERROR;
    }
    ErfaWarning = PyErr_NewException(
        "astropy.erfa._erfa.ErfaWarning", astropy_userwarning, NULL);
    if (ErfaWarning == NULL) {
        INITERROR;
    }
    if (PyModule_AddObject(m, "ErfaWarning", ErfaWarning)) {
        INITERROR;
    }

    ErfaError = PyErr_NewException(
        "astropy.erfa._erfa.ErfaError", PyExc_ValueError, NULL);
    if (ErfaError == NULL) {
        INITERROR;
    }
    if (PyModule_AddObject(m, "ErfaError", ErfaError)) {
        INITERROR;
    }

#if PY3K
    return m;
#endif
}
