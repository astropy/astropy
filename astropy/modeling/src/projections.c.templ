/* -*- mode: c -*- */

/* Licensed under a 3-clause BSD style license - see LICENSE.rst */

/* "projections.c" is auto-generated by erfa_generator.py from the
   template "projections.c.templ". Do *not* edit "projections.c"
   directly. */

#include <Python.h> /* Python */

#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h> /* Numpy */
#include <numpy/npy_math.h> /* Numpy */

#include "prj.h" /* from wcslib */
#include "wcsmath.h"


#if PY_MAJOR_VERSION >= 3
#define PY3K 1
#else
#define PY3K 0
#endif


static void set_error(int status) {
  switch (status) {
  case 1:
    PyErr_SetString(PyExc_MemoryError, "NULL pointer passed");
    break;
  case 2:
    PyErr_SetString(PyExc_ValueError, "Invalid projection parameters");
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError, "Unknown error");
    break;
  }
}


static PyObject *do_work(struct prjprm *prj, PyObject *in[2],
                         int (*prjset)(struct prjprm *),
                         int (*prjtrn)(struct prjprm *, int, int, int, int, const double[], const double[], double[], double[], int[]))
{
  PyArrayObject* in_array[2] = { NULL, NULL };
  PyArrayObject* out_array[2] = { NULL, NULL };
  PyArrayObject* stat_array = NULL;
  Py_ssize_t n;
  Py_ssize_t i;
  PyObject* result = NULL;
  int status = -1;

  prj->phi0 = UNDEFINED;
  prj->theta0 = UNDEFINED;

  if ((status = prjset(prj))) {
    goto exit;
  }

  /* TODO: This assumes the same shape for the input arrays.  Instead,
     we should broadcast */

  for (i = 0; i < 2; ++i) {
    in_array[i] = (PyArrayObject *) PyArray_ContiguousFromObject(
        in[i], NPY_DOUBLE, 1, NPY_MAXDIMS);
    if (in_array[i] == NULL) {
      goto exit;
    }
  }

  if (PyArray_NDIM(in_array[0]) != PyArray_NDIM(in_array[1])) {
    PyErr_SetString(PyExc_ValueError, "input array dimensions do not match");
    goto exit;
  }

  n = 1;
  for (i = 0; i < PyArray_NDIM(in_array[0]); ++i) {
    if (PyArray_DIM(in_array[0], i) != PyArray_DIM(in_array[1], i)) {
      PyErr_SetString(PyExc_ValueError, "input array dimensions do not match");
      goto exit;
    }
    n *= PyArray_DIM(in_array[0], i);
  }

  for (i = 0; i < 2; ++i) {
    out_array[i] = (PyArrayObject *) PyArray_SimpleNew(
        PyArray_NDIM(in_array[0]), PyArray_DIMS(in_array[0]), NPY_DOUBLE);
    if (out_array[i] == NULL) {
      goto exit;
    }
  }

  stat_array = (PyArrayObject *) PyArray_SimpleNew(
      PyArray_NDIM(in_array[0]), PyArray_DIMS(in_array[0]), NPY_INT);
  if (stat_array == NULL) {
    goto exit;
  }

  Py_BEGIN_ALLOW_THREADS

  status = prjtrn(prj, n, 0, 1, 1,
                  (double *)PyArray_DATA(in_array[0]),
                  (double *)PyArray_DATA(in_array[1]),
                  (double *)PyArray_DATA(out_array[0]),
                  (double *)PyArray_DATA(out_array[1]),
                  (int *)PyArray_DATA(stat_array));

  Py_END_ALLOW_THREADS

  if (status) {
    if (status == 3) {
      for (i = 0; i < n; ++i) {
        if (((int *)PyArray_DATA(stat_array))[i]) {
          ((double *)PyArray_DATA(out_array[0]))[i] = NPY_NAN;
          ((double *)PyArray_DATA(out_array[1]))[i] = NPY_NAN;
        }
      }
      status = 0;
    } else {
      goto exit;
    }
  }

  result = Py_BuildValue("(OO)", out_array[0], out_array[1]);

 exit:
  if (status > 0) {
    set_error(status);
  }

  for (i = 0; i < 2; ++i) {
    Py_XDECREF(in_array[i]);
    Py_XDECREF(out_array[i]);
  }
  Py_XDECREF(stat_array);

  return result;
}


{% for name, nargs in projections.items() %}
{% for dir in ['x2s', 's2x'] %}
static PyObject*
Py_{{ name }}{{ dir }}(PyObject* __, PyObject* args, PyObject* kwds)
{
  PyObject* in[2] = { NULL, NULL };

  struct prjprm prj;

  memset(&prj, 0, sizeof(struct prjprm));

  if (!PyArg_ParseTuple(args,
                        "OO"
                        {% for i in range(nargs) %}"d" {% endfor %}
                        ":{{ name }}{{ dir }}",
                        &in[0], &in[1]
                        {% for i in range(nargs) %}
                        {% if loop.first %},{% endif %}
                        &prj.pv[{{i}}{% if name != 'zpn' %} + 1{% endif %}]
                        {% if not loop.last %},{% endif %}
                        {% endfor %}
                        )) {
    return NULL;
  }

  return do_work(&prj, in, {{ name }}set, {{ name }}{{ dir }});
}

{% endfor %}
{% endfor %}


/***************************************************************************
 * Module-level
 ***************************************************************************/

static PyMethodDef module_methods[] = {
  {% for name in projections.keys() %}
  {% for dir in ['x2s', 's2x'] %}
  {"{{ name }}{{ dir }}", (PyCFunction)Py_{{ name }}{{ dir }}, METH_VARARGS, NULL},
  {% endfor %}
  {% endfor %}
  {NULL}  /* Sentinel */
};

struct module_state {
/* The Sun compiler can't handle empty structs */
#if defined(__SUNPRO_C) || defined(_MSC_VER)
    int _dummy;
#endif
};

#if PY3K
    static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "_projections",
        NULL,
        sizeof(struct module_state),
        module_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };

    #define INITERROR return NULL

    PyMODINIT_FUNC
    PyInit__projections(void)

#else
    #define INITERROR return

    PyMODINIT_FUNC
    init_projections(void)
#endif

{
  PyObject* m;

#if PY3K
  m = PyModule_Create(&moduledef);
#else
  m = Py_InitModule3("_projections", module_methods, NULL);
#endif

  if (m == NULL)
    INITERROR;

  import_array();

#ifdef HAVE_WCSLIB_VERSION
  if (PyModule_AddStringConstant(m, "__version__", wcslib_version(NULL))) {
    INITERROR;
  }
#else
  if (PyModule_AddStringConstant(m, "__version__", "4.x")) {
    INITERROR;
  }
#endif

#if PY3K
  return m;
#endif
}
